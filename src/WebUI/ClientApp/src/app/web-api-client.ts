/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.14.4.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface ICacheClient {
    clearAll(): Observable<FileResponse>;
    clearByKey(key: string | null | undefined): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class CacheClient implements ICacheClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    clearAll() : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Cache/ClearAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearAll(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processClearAll(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    clearByKey(key: string | null | undefined) : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Cache/ClearByKey?";
        if (key !== undefined && key !== null)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearByKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearByKey(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processClearByKey(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface ICountriesClient {
    get(id: number): Observable<ResponseOfCountryDto>;
    getList(keyword: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<ResponseOfPaginatedListOfCountryDto>;
    create(command: CreateCountryCommand): Observable<ResponseOfInteger>;
    update(command: UpdateCountryCommand): Observable<ResponseOfUnit>;
    delete(id: number): Observable<ResponseOfUnit>;
}

@Injectable({
    providedIn: 'root'
})
export class CountriesClient implements ICountriesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(id: number) : Observable<ResponseOfCountryDto> {
        let url_ = this.baseUrl + "/api/Countries/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfCountryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfCountryDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ResponseOfCountryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfCountryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfCountryDto>(<any>null);
    }

    getList(keyword: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined) : Observable<ResponseOfPaginatedListOfCountryDto> {
        let url_ = this.baseUrl + "/api/Countries/GetList?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfPaginatedListOfCountryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfPaginatedListOfCountryDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<ResponseOfPaginatedListOfCountryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfPaginatedListOfCountryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfPaginatedListOfCountryDto>(<any>null);
    }

    create(command: CreateCountryCommand) : Observable<ResponseOfInteger> {
        let url_ = this.baseUrl + "/api/Countries/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfInteger>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfInteger>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ResponseOfInteger> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfInteger.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfInteger>(<any>null);
    }

    update(command: UpdateCountryCommand) : Observable<ResponseOfUnit> {
        let url_ = this.baseUrl + "/api/Countries/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfUnit>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfUnit>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ResponseOfUnit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfUnit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfUnit>(<any>null);
    }

    delete(id: number) : Observable<ResponseOfUnit> {
        let url_ = this.baseUrl + "/api/Countries/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfUnit>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfUnit>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ResponseOfUnit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfUnit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfUnit>(<any>null);
    }
}

export interface IProvincesClient {
    get(id: number): Observable<ResponseOfProvinceDto>;
    getList(keyword: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<ResponseOfPaginatedListOfProvinceDto>;
    create(command: CreateProvinceCommand): Observable<ResponseOfInteger>;
    update(command: UpdateProvinceCommand): Observable<ResponseOfUnit>;
    delete(id: number): Observable<ResponseOfUnit>;
}

@Injectable({
    providedIn: 'root'
})
export class ProvincesClient implements IProvincesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(id: number) : Observable<ResponseOfProvinceDto> {
        let url_ = this.baseUrl + "/api/Provinces/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfProvinceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfProvinceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ResponseOfProvinceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfProvinceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfProvinceDto>(<any>null);
    }

    getList(keyword: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined) : Observable<ResponseOfPaginatedListOfProvinceDto> {
        let url_ = this.baseUrl + "/api/Provinces/GetList?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfPaginatedListOfProvinceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfPaginatedListOfProvinceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<ResponseOfPaginatedListOfProvinceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfPaginatedListOfProvinceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfPaginatedListOfProvinceDto>(<any>null);
    }

    create(command: CreateProvinceCommand) : Observable<ResponseOfInteger> {
        let url_ = this.baseUrl + "/api/Provinces/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfInteger>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfInteger>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ResponseOfInteger> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfInteger.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfInteger>(<any>null);
    }

    update(command: UpdateProvinceCommand) : Observable<ResponseOfUnit> {
        let url_ = this.baseUrl + "/api/Provinces/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfUnit>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfUnit>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ResponseOfUnit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfUnit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfUnit>(<any>null);
    }

    delete(id: number) : Observable<ResponseOfUnit> {
        let url_ = this.baseUrl + "/api/Provinces/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfUnit>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfUnit>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ResponseOfUnit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfUnit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfUnit>(<any>null);
    }
}

export interface ITodoItemsClient {
    getTodoItemsWithPagination(listId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfTodoItemBriefDto>;
    create(command: CreateTodoItemCommand): Observable<number>;
    update(id: number, command: UpdateTodoItemCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    updateItemDetails(id: number | undefined, command: UpdateTodoItemDetailCommand): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class TodoItemsClient implements ITodoItemsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getTodoItemsWithPagination(listId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined) : Observable<PaginatedListOfTodoItemBriefDto> {
        let url_ = this.baseUrl + "/api/TodoItems?";
        if (listId === null)
            throw new Error("The parameter 'listId' cannot be null.");
        else if (listId !== undefined)
            url_ += "ListId=" + encodeURIComponent("" + listId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTodoItemsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTodoItemsWithPagination(<any>response_);
                } catch (e) {
                    return <Observable<PaginatedListOfTodoItemBriefDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaginatedListOfTodoItemBriefDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTodoItemsWithPagination(response: HttpResponseBase): Observable<PaginatedListOfTodoItemBriefDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfTodoItemBriefDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfTodoItemBriefDto>(<any>null);
    }

    create(command: CreateTodoItemCommand) : Observable<number> {
        let url_ = this.baseUrl + "/api/TodoItems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    update(id: number, command: UpdateTodoItemCommand) : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoItems/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: number) : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoItems/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    updateItemDetails(id: number | undefined, command: UpdateTodoItemDetailCommand) : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoItems/UpdateItemDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateItemDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateItemDetails(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateItemDetails(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface ITodoListsClient {
    get(): Observable<TodosVm>;
    create(command: CreateTodoListCommand): Observable<number>;
    get2(id: number): Observable<FileResponse>;
    update(id: number, command: UpdateTodoListCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class TodoListsClient implements ITodoListsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get() : Observable<TodosVm> {
        let url_ = this.baseUrl + "/api/TodoLists";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<TodosVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<TodosVm>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TodosVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TodosVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TodosVm>(<any>null);
    }

    create(command: CreateTodoListCommand) : Observable<number> {
        let url_ = this.baseUrl + "/api/TodoLists";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    get2(id: number) : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoLists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet2(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGet2(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    update(id: number, command: UpdateTodoListCommand) : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoLists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: number) : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoLists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IWeatherClient {
    getForecastWeatherIn7Days(provinceId: number | undefined): Observable<ResponseOfWeatherForecastDto>;
    create(request: CreateWeatherDataCommand): Observable<ResponseOfInteger>;
    update(request: UpdateWeatherDataCommand): Observable<ResponseOfUnit>;
    delete(request: DeleteWeatherDataCommand): Observable<ResponseOfUnit>;
    getWeatherConditions(request: GetWeatherConditionQuery | null | undefined): Observable<ResponseOfWeatherConditionCollectionDto>;
}

@Injectable({
    providedIn: 'root'
})
export class WeatherClient implements IWeatherClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getForecastWeatherIn7Days(provinceId: number | undefined) : Observable<ResponseOfWeatherForecastDto> {
        let url_ = this.baseUrl + "/api/Weather/GetForecastWeatherIn7Days?";
        if (provinceId === null)
            throw new Error("The parameter 'provinceId' cannot be null.");
        else if (provinceId !== undefined)
            url_ += "ProvinceId=" + encodeURIComponent("" + provinceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForecastWeatherIn7Days(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForecastWeatherIn7Days(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfWeatherForecastDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfWeatherForecastDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetForecastWeatherIn7Days(response: HttpResponseBase): Observable<ResponseOfWeatherForecastDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfWeatherForecastDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfWeatherForecastDto>(<any>null);
    }

    create(request: CreateWeatherDataCommand) : Observable<ResponseOfInteger> {
        let url_ = this.baseUrl + "/api/Weather/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfInteger>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfInteger>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ResponseOfInteger> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfInteger.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfInteger>(<any>null);
    }

    update(request: UpdateWeatherDataCommand) : Observable<ResponseOfUnit> {
        let url_ = this.baseUrl + "/api/Weather/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfUnit>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfUnit>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ResponseOfUnit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfUnit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfUnit>(<any>null);
    }

    delete(request: DeleteWeatherDataCommand) : Observable<ResponseOfUnit> {
        let url_ = this.baseUrl + "/api/Weather/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfUnit>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfUnit>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ResponseOfUnit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfUnit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfUnit>(<any>null);
    }

    getWeatherConditions(request: GetWeatherConditionQuery | null | undefined) : Observable<ResponseOfWeatherConditionCollectionDto> {
        let url_ = this.baseUrl + "/api/Weather/GetWeatherConditions?";
        if (request !== undefined && request !== null)
            url_ += "request=" + encodeURIComponent("" + request) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeatherConditions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeatherConditions(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfWeatherConditionCollectionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfWeatherConditionCollectionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeatherConditions(response: HttpResponseBase): Observable<ResponseOfWeatherConditionCollectionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfWeatherConditionCollectionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfWeatherConditionCollectionDto>(<any>null);
    }
}

export interface IWeatherForecastClient {
    get(): Observable<WeatherForecast[]>;
}

@Injectable({
    providedIn: 'root'
})
export class WeatherForecastClient implements IWeatherForecastClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get() : Observable<WeatherForecast[]> {
        let url_ = this.baseUrl + "/api/WeatherForecast";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<WeatherForecast[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeatherForecast[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WeatherForecast[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherForecast.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeatherForecast[]>(<any>null);
    }
}

export class Response implements IResponse {
    succeeded?: boolean;
    message?: string | undefined;
    systemError?: string | undefined;
    title?: string | undefined;
    requestTime?: string | undefined;
    responseTime?: string | undefined;

    constructor(data?: IResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.systemError = _data["systemError"];
            this.title = _data["title"];
            this.requestTime = _data["requestTime"];
            this.responseTime = _data["responseTime"];
        }
    }

    static fromJS(data: any): Response {
        data = typeof data === 'object' ? data : {};
        let result = new Response();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["systemError"] = this.systemError;
        data["title"] = this.title;
        data["requestTime"] = this.requestTime;
        data["responseTime"] = this.responseTime;
        return data; 
    }
}

export interface IResponse {
    succeeded?: boolean;
    message?: string | undefined;
    systemError?: string | undefined;
    title?: string | undefined;
    requestTime?: string | undefined;
    responseTime?: string | undefined;
}

export class ResponseOfCountryDto extends Response implements IResponseOfCountryDto {
    data?: CountryDto | undefined;

    constructor(data?: IResponseOfCountryDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.data = _data["data"] ? CountryDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResponseOfCountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseOfCountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IResponseOfCountryDto extends IResponse {
    data?: CountryDto | undefined;
}

export class CountryDto implements ICountryDto {
    id?: number;
    name?: string | undefined;
    priority?: number;
    languageCode?: string | undefined;
    iconUrl?: string | undefined;
    userDefined1?: string | undefined;
    userDefined2?: string | undefined;
    userDefined3?: string | undefined;
    provinces?: ProvinceDto[];

    constructor(data?: ICountryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.priority = _data["priority"];
            this.languageCode = _data["languageCode"];
            this.iconUrl = _data["iconUrl"];
            this.userDefined1 = _data["userDefined1"];
            this.userDefined2 = _data["userDefined2"];
            this.userDefined3 = _data["userDefined3"];
            if (Array.isArray(_data["provinces"])) {
                this.provinces = [] as any;
                for (let item of _data["provinces"])
                    this.provinces!.push(ProvinceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["priority"] = this.priority;
        data["languageCode"] = this.languageCode;
        data["iconUrl"] = this.iconUrl;
        data["userDefined1"] = this.userDefined1;
        data["userDefined2"] = this.userDefined2;
        data["userDefined3"] = this.userDefined3;
        if (Array.isArray(this.provinces)) {
            data["provinces"] = [];
            for (let item of this.provinces)
                data["provinces"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICountryDto {
    id?: number;
    name?: string | undefined;
    priority?: number;
    languageCode?: string | undefined;
    iconUrl?: string | undefined;
    userDefined1?: string | undefined;
    userDefined2?: string | undefined;
    userDefined3?: string | undefined;
    provinces?: ProvinceDto[];
}

export class ProvinceDto implements IProvinceDto {
    id?: number;
    name?: string | undefined;
    aliasName?: string | undefined;
    longitude?: number | undefined;
    latitude?: number | undefined;
    priority?: number;
    countryId?: number | undefined;

    constructor(data?: IProvinceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.aliasName = _data["aliasName"];
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
            this.priority = _data["priority"];
            this.countryId = _data["countryId"];
        }
    }

    static fromJS(data: any): ProvinceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProvinceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["aliasName"] = this.aliasName;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        data["priority"] = this.priority;
        data["countryId"] = this.countryId;
        return data; 
    }
}

export interface IProvinceDto {
    id?: number;
    name?: string | undefined;
    aliasName?: string | undefined;
    longitude?: number | undefined;
    latitude?: number | undefined;
    priority?: number;
    countryId?: number | undefined;
}

export class ResponseOfPaginatedListOfCountryDto extends Response implements IResponseOfPaginatedListOfCountryDto {
    data?: PaginatedListOfCountryDto | undefined;

    constructor(data?: IResponseOfPaginatedListOfCountryDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.data = _data["data"] ? PaginatedListOfCountryDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResponseOfPaginatedListOfCountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseOfPaginatedListOfCountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IResponseOfPaginatedListOfCountryDto extends IResponse {
    data?: PaginatedListOfCountryDto | undefined;
}

export class PaginatedListOfCountryDto implements IPaginatedListOfCountryDto {
    items?: CountryDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfCountryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CountryDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfCountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfCountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IPaginatedListOfCountryDto {
    items?: CountryDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ResponseOfInteger extends Response implements IResponseOfInteger {
    data?: number;

    constructor(data?: IResponseOfInteger) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): ResponseOfInteger {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseOfInteger();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        super.toJSON(data);
        return data; 
    }
}

export interface IResponseOfInteger extends IResponse {
    data?: number;
}

export class CreateCountryCommand implements ICreateCountryCommand {
    name?: string | undefined;
    priority?: number;
    languageCode?: string | undefined;
    iconUrl?: string | undefined;
    userDefined1?: string | undefined;
    userDefined2?: string | undefined;
    userDefined3?: string | undefined;

    constructor(data?: ICreateCountryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.priority = _data["priority"];
            this.languageCode = _data["languageCode"];
            this.iconUrl = _data["iconUrl"];
            this.userDefined1 = _data["userDefined1"];
            this.userDefined2 = _data["userDefined2"];
            this.userDefined3 = _data["userDefined3"];
        }
    }

    static fromJS(data: any): CreateCountryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCountryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["priority"] = this.priority;
        data["languageCode"] = this.languageCode;
        data["iconUrl"] = this.iconUrl;
        data["userDefined1"] = this.userDefined1;
        data["userDefined2"] = this.userDefined2;
        data["userDefined3"] = this.userDefined3;
        return data; 
    }
}

export interface ICreateCountryCommand {
    name?: string | undefined;
    priority?: number;
    languageCode?: string | undefined;
    iconUrl?: string | undefined;
    userDefined1?: string | undefined;
    userDefined2?: string | undefined;
    userDefined3?: string | undefined;
}

export class ResponseOfUnit extends Response implements IResponseOfUnit {
    data?: Unit;

    constructor(data?: IResponseOfUnit) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.data = _data["data"] ? Unit.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResponseOfUnit {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseOfUnit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IResponseOfUnit extends IResponse {
    data?: Unit;
}

/** Represents a void type, since Void is not a valid return type in C#. */
export class Unit implements IUnit {

    constructor(data?: IUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): Unit {
        data = typeof data === 'object' ? data : {};
        let result = new Unit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

/** Represents a void type, since Void is not a valid return type in C#. */
export interface IUnit {
}

export class UpdateCountryCommand implements IUpdateCountryCommand {
    id?: number;
    name?: string | undefined;
    priority?: number;
    languageCode?: string | undefined;
    iconUrl?: string | undefined;
    userDefined1?: string | undefined;
    userDefined2?: string | undefined;
    userDefined3?: string | undefined;

    constructor(data?: IUpdateCountryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.priority = _data["priority"];
            this.languageCode = _data["languageCode"];
            this.iconUrl = _data["iconUrl"];
            this.userDefined1 = _data["userDefined1"];
            this.userDefined2 = _data["userDefined2"];
            this.userDefined3 = _data["userDefined3"];
        }
    }

    static fromJS(data: any): UpdateCountryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCountryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["priority"] = this.priority;
        data["languageCode"] = this.languageCode;
        data["iconUrl"] = this.iconUrl;
        data["userDefined1"] = this.userDefined1;
        data["userDefined2"] = this.userDefined2;
        data["userDefined3"] = this.userDefined3;
        return data; 
    }
}

export interface IUpdateCountryCommand {
    id?: number;
    name?: string | undefined;
    priority?: number;
    languageCode?: string | undefined;
    iconUrl?: string | undefined;
    userDefined1?: string | undefined;
    userDefined2?: string | undefined;
    userDefined3?: string | undefined;
}

export class ResponseOfProvinceDto extends Response implements IResponseOfProvinceDto {
    data?: ProvinceDto | undefined;

    constructor(data?: IResponseOfProvinceDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.data = _data["data"] ? ProvinceDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResponseOfProvinceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseOfProvinceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IResponseOfProvinceDto extends IResponse {
    data?: ProvinceDto | undefined;
}

export class ResponseOfPaginatedListOfProvinceDto extends Response implements IResponseOfPaginatedListOfProvinceDto {
    data?: PaginatedListOfProvinceDto | undefined;

    constructor(data?: IResponseOfPaginatedListOfProvinceDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.data = _data["data"] ? PaginatedListOfProvinceDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResponseOfPaginatedListOfProvinceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseOfPaginatedListOfProvinceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IResponseOfPaginatedListOfProvinceDto extends IResponse {
    data?: PaginatedListOfProvinceDto | undefined;
}

export class PaginatedListOfProvinceDto implements IPaginatedListOfProvinceDto {
    items?: ProvinceDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfProvinceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProvinceDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfProvinceDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfProvinceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IPaginatedListOfProvinceDto {
    items?: ProvinceDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class CreateProvinceCommand implements ICreateProvinceCommand {
    name?: string | undefined;
    longitude?: number | undefined;
    latitude?: number | undefined;
    priority?: number;
    aliasName?: string | undefined;
    countryId?: number | undefined;

    constructor(data?: ICreateProvinceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
            this.priority = _data["priority"];
            this.aliasName = _data["aliasName"];
            this.countryId = _data["countryId"];
        }
    }

    static fromJS(data: any): CreateProvinceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProvinceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        data["priority"] = this.priority;
        data["aliasName"] = this.aliasName;
        data["countryId"] = this.countryId;
        return data; 
    }
}

export interface ICreateProvinceCommand {
    name?: string | undefined;
    longitude?: number | undefined;
    latitude?: number | undefined;
    priority?: number;
    aliasName?: string | undefined;
    countryId?: number | undefined;
}

export class UpdateProvinceCommand implements IUpdateProvinceCommand {
    id?: number;
    name?: string | undefined;
    longitude?: number | undefined;
    latitude?: number | undefined;
    priority?: number;
    aliasName?: string | undefined;
    countryId?: number | undefined;

    constructor(data?: IUpdateProvinceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
            this.priority = _data["priority"];
            this.aliasName = _data["aliasName"];
            this.countryId = _data["countryId"];
        }
    }

    static fromJS(data: any): UpdateProvinceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProvinceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        data["priority"] = this.priority;
        data["aliasName"] = this.aliasName;
        data["countryId"] = this.countryId;
        return data; 
    }
}

export interface IUpdateProvinceCommand {
    id?: number;
    name?: string | undefined;
    longitude?: number | undefined;
    latitude?: number | undefined;
    priority?: number;
    aliasName?: string | undefined;
    countryId?: number | undefined;
}

export class PaginatedListOfTodoItemBriefDto implements IPaginatedListOfTodoItemBriefDto {
    items?: TodoItemBriefDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfTodoItemBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TodoItemBriefDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfTodoItemBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfTodoItemBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IPaginatedListOfTodoItemBriefDto {
    items?: TodoItemBriefDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class TodoItemBriefDto implements ITodoItemBriefDto {
    id?: number;
    listId?: number;
    title?: string | undefined;
    done?: boolean;

    constructor(data?: ITodoItemBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.listId = _data["listId"];
            this.title = _data["title"];
            this.done = _data["done"];
        }
    }

    static fromJS(data: any): TodoItemBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new TodoItemBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["listId"] = this.listId;
        data["title"] = this.title;
        data["done"] = this.done;
        return data; 
    }
}

export interface ITodoItemBriefDto {
    id?: number;
    listId?: number;
    title?: string | undefined;
    done?: boolean;
}

export class CreateTodoItemCommand implements ICreateTodoItemCommand {
    listId?: number;
    title?: string | undefined;

    constructor(data?: ICreateTodoItemCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.listId = _data["listId"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): CreateTodoItemCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTodoItemCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["listId"] = this.listId;
        data["title"] = this.title;
        return data; 
    }
}

export interface ICreateTodoItemCommand {
    listId?: number;
    title?: string | undefined;
}

export class UpdateTodoItemCommand implements IUpdateTodoItemCommand {
    id?: number;
    title?: string | undefined;
    done?: boolean;

    constructor(data?: IUpdateTodoItemCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.done = _data["done"];
        }
    }

    static fromJS(data: any): UpdateTodoItemCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTodoItemCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["done"] = this.done;
        return data; 
    }
}

export interface IUpdateTodoItemCommand {
    id?: number;
    title?: string | undefined;
    done?: boolean;
}

export class UpdateTodoItemDetailCommand implements IUpdateTodoItemDetailCommand {
    id?: number;
    listId?: number;
    priority?: PriorityLevel;
    note?: string | undefined;

    constructor(data?: IUpdateTodoItemDetailCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.listId = _data["listId"];
            this.priority = _data["priority"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): UpdateTodoItemDetailCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTodoItemDetailCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["listId"] = this.listId;
        data["priority"] = this.priority;
        data["note"] = this.note;
        return data; 
    }
}

export interface IUpdateTodoItemDetailCommand {
    id?: number;
    listId?: number;
    priority?: PriorityLevel;
    note?: string | undefined;
}

export enum PriorityLevel {
    None = 0,
    Low = 1,
    Medium = 2,
    High = 3,
}

export class TodosVm implements ITodosVm {
    priorityLevels?: PriorityLevelDto[];
    lists?: TodoListDto[];

    constructor(data?: ITodosVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["priorityLevels"])) {
                this.priorityLevels = [] as any;
                for (let item of _data["priorityLevels"])
                    this.priorityLevels!.push(PriorityLevelDto.fromJS(item));
            }
            if (Array.isArray(_data["lists"])) {
                this.lists = [] as any;
                for (let item of _data["lists"])
                    this.lists!.push(TodoListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TodosVm {
        data = typeof data === 'object' ? data : {};
        let result = new TodosVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.priorityLevels)) {
            data["priorityLevels"] = [];
            for (let item of this.priorityLevels)
                data["priorityLevels"].push(item.toJSON());
        }
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITodosVm {
    priorityLevels?: PriorityLevelDto[];
    lists?: TodoListDto[];
}

export class PriorityLevelDto implements IPriorityLevelDto {
    value?: number;
    name?: string | undefined;

    constructor(data?: IPriorityLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): PriorityLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new PriorityLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["name"] = this.name;
        return data; 
    }
}

export interface IPriorityLevelDto {
    value?: number;
    name?: string | undefined;
}

export class TodoListDto implements ITodoListDto {
    id?: number;
    title?: string | undefined;
    colour?: string | undefined;
    items?: TodoItemDto[];

    constructor(data?: ITodoListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.colour = _data["colour"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TodoItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TodoListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TodoListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["colour"] = this.colour;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITodoListDto {
    id?: number;
    title?: string | undefined;
    colour?: string | undefined;
    items?: TodoItemDto[];
}

export class TodoItemDto implements ITodoItemDto {
    id?: number;
    listId?: number;
    title?: string | undefined;
    done?: boolean;
    priority?: number;
    note?: string | undefined;

    constructor(data?: ITodoItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.listId = _data["listId"];
            this.title = _data["title"];
            this.done = _data["done"];
            this.priority = _data["priority"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): TodoItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new TodoItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["listId"] = this.listId;
        data["title"] = this.title;
        data["done"] = this.done;
        data["priority"] = this.priority;
        data["note"] = this.note;
        return data; 
    }
}

export interface ITodoItemDto {
    id?: number;
    listId?: number;
    title?: string | undefined;
    done?: boolean;
    priority?: number;
    note?: string | undefined;
}

export class CreateTodoListCommand implements ICreateTodoListCommand {
    title?: string | undefined;

    constructor(data?: ICreateTodoListCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): CreateTodoListCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTodoListCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        return data; 
    }
}

export interface ICreateTodoListCommand {
    title?: string | undefined;
}

export class UpdateTodoListCommand implements IUpdateTodoListCommand {
    id?: number;
    title?: string | undefined;

    constructor(data?: IUpdateTodoListCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): UpdateTodoListCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTodoListCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        return data; 
    }
}

export interface IUpdateTodoListCommand {
    id?: number;
    title?: string | undefined;
}

export class ResponseOfWeatherForecastDto extends Response implements IResponseOfWeatherForecastDto {
    data?: WeatherForecastDto | undefined;

    constructor(data?: IResponseOfWeatherForecastDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.data = _data["data"] ? WeatherForecastDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResponseOfWeatherForecastDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseOfWeatherForecastDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IResponseOfWeatherForecastDto extends IResponse {
    data?: WeatherForecastDto | undefined;
}

export class WeatherForecastDto implements IWeatherForecastDto {
    daily?: DailyForecastWeatherDto[];

    constructor(data?: IWeatherForecastDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["daily"])) {
                this.daily = [] as any;
                for (let item of _data["daily"])
                    this.daily!.push(DailyForecastWeatherDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WeatherForecastDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecastDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.daily)) {
            data["daily"] = [];
            for (let item of this.daily)
                data["daily"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IWeatherForecastDto {
    daily?: DailyForecastWeatherDto[];
}

export class DailyForecastWeatherDto implements IDailyForecastWeatherDto {
    id?: number;
    dt?: number;
    sunrise?: number;
    sunset?: number;
    temp_avg?: number;
    temp_min?: number;
    temp_max?: number;
    humidity?: number;
    dew_point?: number;
    pop?: number;
    wind_speed?: number;
    clouds?: number;
    weather_id?: number;
    weather_main?: string | undefined;
    weather_description?: string | undefined;
    weather_icon?: string | undefined;
    temp_morn?: number;
    temp_day?: number;
    temp_eve?: number;
    temp_night?: number;
    weatherId_morn?: number;
    weatherMain_morn?: string | undefined;
    weatherDesc_morn?: string | undefined;
    weatherIcon_morn?: string | undefined;
    weatherId_day?: number;
    weatherMain_day?: string | undefined;
    weatherDesc_day?: string | undefined;
    weatherIcon_day?: string | undefined;
    weatherId_eve?: number;
    weatherMain_eve?: string | undefined;
    weatherDesc_eve?: string | undefined;
    weatherIcon_eve?: string | undefined;
    weatherId_night?: number;
    weatherMain_night?: string | undefined;
    weatherDesc_night?: string | undefined;
    weatherIcon_night?: string | undefined;

    constructor(data?: IDailyForecastWeatherDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dt = _data["dt"];
            this.sunrise = _data["sunrise"];
            this.sunset = _data["sunset"];
            this.temp_avg = _data["temp_avg"];
            this.temp_min = _data["temp_min"];
            this.temp_max = _data["temp_max"];
            this.humidity = _data["humidity"];
            this.dew_point = _data["dew_point"];
            this.pop = _data["pop"];
            this.wind_speed = _data["wind_speed"];
            this.clouds = _data["clouds"];
            this.weather_id = _data["weather_id"];
            this.weather_main = _data["weather_main"];
            this.weather_description = _data["weather_description"];
            this.weather_icon = _data["weather_icon"];
            this.temp_morn = _data["temp_morn"];
            this.temp_day = _data["temp_day"];
            this.temp_eve = _data["temp_eve"];
            this.temp_night = _data["temp_night"];
            this.weatherId_morn = _data["weatherId_morn"];
            this.weatherMain_morn = _data["weatherMain_morn"];
            this.weatherDesc_morn = _data["weatherDesc_morn"];
            this.weatherIcon_morn = _data["weatherIcon_morn"];
            this.weatherId_day = _data["weatherId_day"];
            this.weatherMain_day = _data["weatherMain_day"];
            this.weatherDesc_day = _data["weatherDesc_day"];
            this.weatherIcon_day = _data["weatherIcon_day"];
            this.weatherId_eve = _data["weatherId_eve"];
            this.weatherMain_eve = _data["weatherMain_eve"];
            this.weatherDesc_eve = _data["weatherDesc_eve"];
            this.weatherIcon_eve = _data["weatherIcon_eve"];
            this.weatherId_night = _data["weatherId_night"];
            this.weatherMain_night = _data["weatherMain_night"];
            this.weatherDesc_night = _data["weatherDesc_night"];
            this.weatherIcon_night = _data["weatherIcon_night"];
        }
    }

    static fromJS(data: any): DailyForecastWeatherDto {
        data = typeof data === 'object' ? data : {};
        let result = new DailyForecastWeatherDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dt"] = this.dt;
        data["sunrise"] = this.sunrise;
        data["sunset"] = this.sunset;
        data["temp_avg"] = this.temp_avg;
        data["temp_min"] = this.temp_min;
        data["temp_max"] = this.temp_max;
        data["humidity"] = this.humidity;
        data["dew_point"] = this.dew_point;
        data["pop"] = this.pop;
        data["wind_speed"] = this.wind_speed;
        data["clouds"] = this.clouds;
        data["weather_id"] = this.weather_id;
        data["weather_main"] = this.weather_main;
        data["weather_description"] = this.weather_description;
        data["weather_icon"] = this.weather_icon;
        data["temp_morn"] = this.temp_morn;
        data["temp_day"] = this.temp_day;
        data["temp_eve"] = this.temp_eve;
        data["temp_night"] = this.temp_night;
        data["weatherId_morn"] = this.weatherId_morn;
        data["weatherMain_morn"] = this.weatherMain_morn;
        data["weatherDesc_morn"] = this.weatherDesc_morn;
        data["weatherIcon_morn"] = this.weatherIcon_morn;
        data["weatherId_day"] = this.weatherId_day;
        data["weatherMain_day"] = this.weatherMain_day;
        data["weatherDesc_day"] = this.weatherDesc_day;
        data["weatherIcon_day"] = this.weatherIcon_day;
        data["weatherId_eve"] = this.weatherId_eve;
        data["weatherMain_eve"] = this.weatherMain_eve;
        data["weatherDesc_eve"] = this.weatherDesc_eve;
        data["weatherIcon_eve"] = this.weatherIcon_eve;
        data["weatherId_night"] = this.weatherId_night;
        data["weatherMain_night"] = this.weatherMain_night;
        data["weatherDesc_night"] = this.weatherDesc_night;
        data["weatherIcon_night"] = this.weatherIcon_night;
        return data; 
    }
}

export interface IDailyForecastWeatherDto {
    id?: number;
    dt?: number;
    sunrise?: number;
    sunset?: number;
    temp_avg?: number;
    temp_min?: number;
    temp_max?: number;
    humidity?: number;
    dew_point?: number;
    pop?: number;
    wind_speed?: number;
    clouds?: number;
    weather_id?: number;
    weather_main?: string | undefined;
    weather_description?: string | undefined;
    weather_icon?: string | undefined;
    temp_morn?: number;
    temp_day?: number;
    temp_eve?: number;
    temp_night?: number;
    weatherId_morn?: number;
    weatherMain_morn?: string | undefined;
    weatherDesc_morn?: string | undefined;
    weatherIcon_morn?: string | undefined;
    weatherId_day?: number;
    weatherMain_day?: string | undefined;
    weatherDesc_day?: string | undefined;
    weatherIcon_day?: string | undefined;
    weatherId_eve?: number;
    weatherMain_eve?: string | undefined;
    weatherDesc_eve?: string | undefined;
    weatherIcon_eve?: string | undefined;
    weatherId_night?: number;
    weatherMain_night?: string | undefined;
    weatherDesc_night?: string | undefined;
    weatherIcon_night?: string | undefined;
}

export class CreateWeatherDataCommand implements ICreateWeatherDataCommand {
    provinceId?: number;
    dt?: number;
    sunrise?: number;
    sunset?: number;
    temp_avg?: number;
    temp_min?: number;
    temp_max?: number;
    humidity?: number;
    dew_point?: number;
    pop?: number;
    wind_speed?: number;
    clouds?: number;
    weather_id?: number;
    weather_main?: string | undefined;
    weather_description?: string | undefined;
    weather_icon?: string | undefined;
    temp_morn?: number;
    temp_day?: number;
    temp_eve?: number;
    temp_night?: number;
    weatherId_morn?: number;
    weatherMain_morn?: string | undefined;
    weatherDesc_morn?: string | undefined;
    weatherIcon_morn?: string | undefined;
    weatherId_day?: number;
    weatherMain_day?: string | undefined;
    weatherDesc_day?: string | undefined;
    weatherIcon_day?: string | undefined;
    weatherId_eve?: number;
    weatherMain_eve?: string | undefined;
    weatherDesc_eve?: string | undefined;
    weatherIcon_eve?: string | undefined;
    weatherId_night?: number;
    weatherMain_night?: string | undefined;
    weatherDesc_night?: string | undefined;
    weatherIcon_night?: string | undefined;

    constructor(data?: ICreateWeatherDataCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.provinceId = _data["provinceId"];
            this.dt = _data["dt"];
            this.sunrise = _data["sunrise"];
            this.sunset = _data["sunset"];
            this.temp_avg = _data["temp_avg"];
            this.temp_min = _data["temp_min"];
            this.temp_max = _data["temp_max"];
            this.humidity = _data["humidity"];
            this.dew_point = _data["dew_point"];
            this.pop = _data["pop"];
            this.wind_speed = _data["wind_speed"];
            this.clouds = _data["clouds"];
            this.weather_id = _data["weather_id"];
            this.weather_main = _data["weather_main"];
            this.weather_description = _data["weather_description"];
            this.weather_icon = _data["weather_icon"];
            this.temp_morn = _data["temp_morn"];
            this.temp_day = _data["temp_day"];
            this.temp_eve = _data["temp_eve"];
            this.temp_night = _data["temp_night"];
            this.weatherId_morn = _data["weatherId_morn"];
            this.weatherMain_morn = _data["weatherMain_morn"];
            this.weatherDesc_morn = _data["weatherDesc_morn"];
            this.weatherIcon_morn = _data["weatherIcon_morn"];
            this.weatherId_day = _data["weatherId_day"];
            this.weatherMain_day = _data["weatherMain_day"];
            this.weatherDesc_day = _data["weatherDesc_day"];
            this.weatherIcon_day = _data["weatherIcon_day"];
            this.weatherId_eve = _data["weatherId_eve"];
            this.weatherMain_eve = _data["weatherMain_eve"];
            this.weatherDesc_eve = _data["weatherDesc_eve"];
            this.weatherIcon_eve = _data["weatherIcon_eve"];
            this.weatherId_night = _data["weatherId_night"];
            this.weatherMain_night = _data["weatherMain_night"];
            this.weatherDesc_night = _data["weatherDesc_night"];
            this.weatherIcon_night = _data["weatherIcon_night"];
        }
    }

    static fromJS(data: any): CreateWeatherDataCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWeatherDataCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["provinceId"] = this.provinceId;
        data["dt"] = this.dt;
        data["sunrise"] = this.sunrise;
        data["sunset"] = this.sunset;
        data["temp_avg"] = this.temp_avg;
        data["temp_min"] = this.temp_min;
        data["temp_max"] = this.temp_max;
        data["humidity"] = this.humidity;
        data["dew_point"] = this.dew_point;
        data["pop"] = this.pop;
        data["wind_speed"] = this.wind_speed;
        data["clouds"] = this.clouds;
        data["weather_id"] = this.weather_id;
        data["weather_main"] = this.weather_main;
        data["weather_description"] = this.weather_description;
        data["weather_icon"] = this.weather_icon;
        data["temp_morn"] = this.temp_morn;
        data["temp_day"] = this.temp_day;
        data["temp_eve"] = this.temp_eve;
        data["temp_night"] = this.temp_night;
        data["weatherId_morn"] = this.weatherId_morn;
        data["weatherMain_morn"] = this.weatherMain_morn;
        data["weatherDesc_morn"] = this.weatherDesc_morn;
        data["weatherIcon_morn"] = this.weatherIcon_morn;
        data["weatherId_day"] = this.weatherId_day;
        data["weatherMain_day"] = this.weatherMain_day;
        data["weatherDesc_day"] = this.weatherDesc_day;
        data["weatherIcon_day"] = this.weatherIcon_day;
        data["weatherId_eve"] = this.weatherId_eve;
        data["weatherMain_eve"] = this.weatherMain_eve;
        data["weatherDesc_eve"] = this.weatherDesc_eve;
        data["weatherIcon_eve"] = this.weatherIcon_eve;
        data["weatherId_night"] = this.weatherId_night;
        data["weatherMain_night"] = this.weatherMain_night;
        data["weatherDesc_night"] = this.weatherDesc_night;
        data["weatherIcon_night"] = this.weatherIcon_night;
        return data; 
    }
}

export interface ICreateWeatherDataCommand {
    provinceId?: number;
    dt?: number;
    sunrise?: number;
    sunset?: number;
    temp_avg?: number;
    temp_min?: number;
    temp_max?: number;
    humidity?: number;
    dew_point?: number;
    pop?: number;
    wind_speed?: number;
    clouds?: number;
    weather_id?: number;
    weather_main?: string | undefined;
    weather_description?: string | undefined;
    weather_icon?: string | undefined;
    temp_morn?: number;
    temp_day?: number;
    temp_eve?: number;
    temp_night?: number;
    weatherId_morn?: number;
    weatherMain_morn?: string | undefined;
    weatherDesc_morn?: string | undefined;
    weatherIcon_morn?: string | undefined;
    weatherId_day?: number;
    weatherMain_day?: string | undefined;
    weatherDesc_day?: string | undefined;
    weatherIcon_day?: string | undefined;
    weatherId_eve?: number;
    weatherMain_eve?: string | undefined;
    weatherDesc_eve?: string | undefined;
    weatherIcon_eve?: string | undefined;
    weatherId_night?: number;
    weatherMain_night?: string | undefined;
    weatherDesc_night?: string | undefined;
    weatherIcon_night?: string | undefined;
}

export class UpdateWeatherDataCommand implements IUpdateWeatherDataCommand {
    id?: number;
    sunrise?: number;
    sunset?: number;
    temp_avg?: number;
    temp_min?: number;
    temp_max?: number;
    humidity?: number;
    dew_point?: number;
    pop?: number;
    wind_speed?: number;
    clouds?: number;
    weather_id?: number;
    weather_main?: string | undefined;
    weather_description?: string | undefined;
    weather_icon?: string | undefined;
    temp_morn?: number;
    temp_day?: number;
    temp_eve?: number;
    temp_night?: number;
    weatherId_morn?: number;
    weatherMain_morn?: string | undefined;
    weatherDesc_morn?: string | undefined;
    weatherIcon_morn?: string | undefined;
    weatherId_day?: number;
    weatherMain_day?: string | undefined;
    weatherDesc_day?: string | undefined;
    weatherIcon_day?: string | undefined;
    weatherId_eve?: number;
    weatherMain_eve?: string | undefined;
    weatherDesc_eve?: string | undefined;
    weatherIcon_eve?: string | undefined;
    weatherId_night?: number;
    weatherMain_night?: string | undefined;
    weatherDesc_night?: string | undefined;
    weatherIcon_night?: string | undefined;

    constructor(data?: IUpdateWeatherDataCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sunrise = _data["sunrise"];
            this.sunset = _data["sunset"];
            this.temp_avg = _data["temp_avg"];
            this.temp_min = _data["temp_min"];
            this.temp_max = _data["temp_max"];
            this.humidity = _data["humidity"];
            this.dew_point = _data["dew_point"];
            this.pop = _data["pop"];
            this.wind_speed = _data["wind_speed"];
            this.clouds = _data["clouds"];
            this.weather_id = _data["weather_id"];
            this.weather_main = _data["weather_main"];
            this.weather_description = _data["weather_description"];
            this.weather_icon = _data["weather_icon"];
            this.temp_morn = _data["temp_morn"];
            this.temp_day = _data["temp_day"];
            this.temp_eve = _data["temp_eve"];
            this.temp_night = _data["temp_night"];
            this.weatherId_morn = _data["weatherId_morn"];
            this.weatherMain_morn = _data["weatherMain_morn"];
            this.weatherDesc_morn = _data["weatherDesc_morn"];
            this.weatherIcon_morn = _data["weatherIcon_morn"];
            this.weatherId_day = _data["weatherId_day"];
            this.weatherMain_day = _data["weatherMain_day"];
            this.weatherDesc_day = _data["weatherDesc_day"];
            this.weatherIcon_day = _data["weatherIcon_day"];
            this.weatherId_eve = _data["weatherId_eve"];
            this.weatherMain_eve = _data["weatherMain_eve"];
            this.weatherDesc_eve = _data["weatherDesc_eve"];
            this.weatherIcon_eve = _data["weatherIcon_eve"];
            this.weatherId_night = _data["weatherId_night"];
            this.weatherMain_night = _data["weatherMain_night"];
            this.weatherDesc_night = _data["weatherDesc_night"];
            this.weatherIcon_night = _data["weatherIcon_night"];
        }
    }

    static fromJS(data: any): UpdateWeatherDataCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateWeatherDataCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sunrise"] = this.sunrise;
        data["sunset"] = this.sunset;
        data["temp_avg"] = this.temp_avg;
        data["temp_min"] = this.temp_min;
        data["temp_max"] = this.temp_max;
        data["humidity"] = this.humidity;
        data["dew_point"] = this.dew_point;
        data["pop"] = this.pop;
        data["wind_speed"] = this.wind_speed;
        data["clouds"] = this.clouds;
        data["weather_id"] = this.weather_id;
        data["weather_main"] = this.weather_main;
        data["weather_description"] = this.weather_description;
        data["weather_icon"] = this.weather_icon;
        data["temp_morn"] = this.temp_morn;
        data["temp_day"] = this.temp_day;
        data["temp_eve"] = this.temp_eve;
        data["temp_night"] = this.temp_night;
        data["weatherId_morn"] = this.weatherId_morn;
        data["weatherMain_morn"] = this.weatherMain_morn;
        data["weatherDesc_morn"] = this.weatherDesc_morn;
        data["weatherIcon_morn"] = this.weatherIcon_morn;
        data["weatherId_day"] = this.weatherId_day;
        data["weatherMain_day"] = this.weatherMain_day;
        data["weatherDesc_day"] = this.weatherDesc_day;
        data["weatherIcon_day"] = this.weatherIcon_day;
        data["weatherId_eve"] = this.weatherId_eve;
        data["weatherMain_eve"] = this.weatherMain_eve;
        data["weatherDesc_eve"] = this.weatherDesc_eve;
        data["weatherIcon_eve"] = this.weatherIcon_eve;
        data["weatherId_night"] = this.weatherId_night;
        data["weatherMain_night"] = this.weatherMain_night;
        data["weatherDesc_night"] = this.weatherDesc_night;
        data["weatherIcon_night"] = this.weatherIcon_night;
        return data; 
    }
}

export interface IUpdateWeatherDataCommand {
    id?: number;
    sunrise?: number;
    sunset?: number;
    temp_avg?: number;
    temp_min?: number;
    temp_max?: number;
    humidity?: number;
    dew_point?: number;
    pop?: number;
    wind_speed?: number;
    clouds?: number;
    weather_id?: number;
    weather_main?: string | undefined;
    weather_description?: string | undefined;
    weather_icon?: string | undefined;
    temp_morn?: number;
    temp_day?: number;
    temp_eve?: number;
    temp_night?: number;
    weatherId_morn?: number;
    weatherMain_morn?: string | undefined;
    weatherDesc_morn?: string | undefined;
    weatherIcon_morn?: string | undefined;
    weatherId_day?: number;
    weatherMain_day?: string | undefined;
    weatherDesc_day?: string | undefined;
    weatherIcon_day?: string | undefined;
    weatherId_eve?: number;
    weatherMain_eve?: string | undefined;
    weatherDesc_eve?: string | undefined;
    weatherIcon_eve?: string | undefined;
    weatherId_night?: number;
    weatherMain_night?: string | undefined;
    weatherDesc_night?: string | undefined;
    weatherIcon_night?: string | undefined;
}

export class DeleteWeatherDataCommand implements IDeleteWeatherDataCommand {
    id?: number;

    constructor(data?: IDeleteWeatherDataCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DeleteWeatherDataCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteWeatherDataCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IDeleteWeatherDataCommand {
    id?: number;
}

export class ResponseOfWeatherConditionCollectionDto extends Response implements IResponseOfWeatherConditionCollectionDto {
    data?: WeatherConditionCollectionDto | undefined;

    constructor(data?: IResponseOfWeatherConditionCollectionDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.data = _data["data"] ? WeatherConditionCollectionDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResponseOfWeatherConditionCollectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseOfWeatherConditionCollectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IResponseOfWeatherConditionCollectionDto extends IResponse {
    data?: WeatherConditionCollectionDto | undefined;
}

export class WeatherConditionCollectionDto implements IWeatherConditionCollectionDto {
    weatherConditionGroups?: OWPWeatherConditionGroup[];
    weatherConditions?: OWPWeatherCondition[];

    constructor(data?: IWeatherConditionCollectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["weatherConditionGroups"])) {
                this.weatherConditionGroups = [] as any;
                for (let item of _data["weatherConditionGroups"])
                    this.weatherConditionGroups!.push(OWPWeatherConditionGroup.fromJS(item));
            }
            if (Array.isArray(_data["weatherConditions"])) {
                this.weatherConditions = [] as any;
                for (let item of _data["weatherConditions"])
                    this.weatherConditions!.push(OWPWeatherCondition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WeatherConditionCollectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherConditionCollectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.weatherConditionGroups)) {
            data["weatherConditionGroups"] = [];
            for (let item of this.weatherConditionGroups)
                data["weatherConditionGroups"].push(item.toJSON());
        }
        if (Array.isArray(this.weatherConditions)) {
            data["weatherConditions"] = [];
            for (let item of this.weatherConditions)
                data["weatherConditions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IWeatherConditionCollectionDto {
    weatherConditionGroups?: OWPWeatherConditionGroup[];
    weatherConditions?: OWPWeatherCondition[];
}

export class OWPWeatherConditionGroup implements IOWPWeatherConditionGroup {
    id?: string | undefined;
    name?: string | undefined;
    orderIndex?: number;

    constructor(data?: IOWPWeatherConditionGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.orderIndex = _data["orderIndex"];
        }
    }

    static fromJS(data: any): OWPWeatherConditionGroup {
        data = typeof data === 'object' ? data : {};
        let result = new OWPWeatherConditionGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["orderIndex"] = this.orderIndex;
        return data; 
    }
}

export interface IOWPWeatherConditionGroup {
    id?: string | undefined;
    name?: string | undefined;
    orderIndex?: number;
}

export class OWPWeatherCondition implements IOWPWeatherCondition {
    id?: number;
    main?: string | undefined;
    description?: string | undefined;
    icon?: string | undefined;
    iconUrl?: string;
    weatherConditionGroupId?: string | undefined;

    constructor(data?: IOWPWeatherCondition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.main = _data["main"];
            this.description = _data["description"];
            this.icon = _data["icon"];
            this.iconUrl = _data["iconUrl"];
            this.weatherConditionGroupId = _data["weatherConditionGroupId"];
        }
    }

    static fromJS(data: any): OWPWeatherCondition {
        data = typeof data === 'object' ? data : {};
        let result = new OWPWeatherCondition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["main"] = this.main;
        data["description"] = this.description;
        data["icon"] = this.icon;
        data["iconUrl"] = this.iconUrl;
        data["weatherConditionGroupId"] = this.weatherConditionGroupId;
        return data; 
    }
}

export interface IOWPWeatherCondition {
    id?: number;
    main?: string | undefined;
    description?: string | undefined;
    icon?: string | undefined;
    iconUrl?: string;
    weatherConditionGroupId?: string | undefined;
}

export class GetWeatherConditionQuery implements IGetWeatherConditionQuery {

    constructor(data?: IGetWeatherConditionQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): GetWeatherConditionQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetWeatherConditionQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IGetWeatherConditionQuery {
}

export class WeatherForecast implements IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.temperatureC = _data["temperatureC"];
            this.temperatureF = _data["temperatureF"];
            this.summary = _data["summary"];
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["temperatureC"] = this.temperatureC;
        data["temperatureF"] = this.temperatureF;
        data["summary"] = this.summary;
        return data; 
    }
}

export interface IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}