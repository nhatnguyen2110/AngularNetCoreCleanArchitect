/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.14.4.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IAccountClient {
    signUp(command: SignUpCommand): Observable<ResponseOfUnit>;
    signIn(command: SignInCommand): Observable<ResponseOfSignInResultDto>;
    activation(command: ActivationCommand): Observable<ResponseOfUnit>;
    getEmailVerificationCode(command: GetEmailVerificationCodeCommand): Observable<ResponseOfEmailVerificationCodeResultDto>;
    signInByEmailVerificationCode(command: SignInByEmailVerificationCodeCommand): Observable<ResponseOfSignInResultDto>;
    getEmailResetPassword(command: GetEmailResetPasswordCommand): Observable<ResponseOfUnit>;
    resetPassword(command: ResetPasswordCommand): Observable<ResponseOfUnit>;
    getProfile(requestId: string | null | undefined): Observable<ResponseOfAccountDto>;
    refreshToken(command: RefreshTokenCommand): Observable<ResponseOfSignInResultDto>;
    facebookLogin(command: FacebookLoginCommand): Observable<ResponseOfSignInResultDto>;
    googleLogin(command: GoogleLoginCommand): Observable<ResponseOfSignInResultDto>;
}

@Injectable({
    providedIn: 'root'
})
export class AccountClient implements IAccountClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    signUp(command: SignUpCommand) : Observable<ResponseOfUnit> {
        let url_ = this.baseUrl + "/api/Account/SignUp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignUp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignUp(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfUnit>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfUnit>><any>_observableThrow(response_);
        }));
    }

    protected processSignUp(response: HttpResponseBase): Observable<ResponseOfUnit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfUnit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfUnit>(<any>null);
    }

    signIn(command: SignInCommand) : Observable<ResponseOfSignInResultDto> {
        let url_ = this.baseUrl + "/api/Account/SignIn";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignIn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignIn(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfSignInResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfSignInResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processSignIn(response: HttpResponseBase): Observable<ResponseOfSignInResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfSignInResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfSignInResultDto>(<any>null);
    }

    activation(command: ActivationCommand) : Observable<ResponseOfUnit> {
        let url_ = this.baseUrl + "/api/Account/Activation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivation(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfUnit>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfUnit>><any>_observableThrow(response_);
        }));
    }

    protected processActivation(response: HttpResponseBase): Observable<ResponseOfUnit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfUnit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfUnit>(<any>null);
    }

    getEmailVerificationCode(command: GetEmailVerificationCodeCommand) : Observable<ResponseOfEmailVerificationCodeResultDto> {
        let url_ = this.baseUrl + "/api/Account/GetEmailVerificationCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmailVerificationCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailVerificationCode(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfEmailVerificationCodeResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfEmailVerificationCodeResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmailVerificationCode(response: HttpResponseBase): Observable<ResponseOfEmailVerificationCodeResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfEmailVerificationCodeResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfEmailVerificationCodeResultDto>(<any>null);
    }

    signInByEmailVerificationCode(command: SignInByEmailVerificationCodeCommand) : Observable<ResponseOfSignInResultDto> {
        let url_ = this.baseUrl + "/api/Account/SignInByEmailVerificationCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignInByEmailVerificationCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignInByEmailVerificationCode(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfSignInResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfSignInResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processSignInByEmailVerificationCode(response: HttpResponseBase): Observable<ResponseOfSignInResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfSignInResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfSignInResultDto>(<any>null);
    }

    getEmailResetPassword(command: GetEmailResetPasswordCommand) : Observable<ResponseOfUnit> {
        let url_ = this.baseUrl + "/api/Account/GetEmailResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmailResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfUnit>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfUnit>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmailResetPassword(response: HttpResponseBase): Observable<ResponseOfUnit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfUnit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfUnit>(<any>null);
    }

    resetPassword(command: ResetPasswordCommand) : Observable<ResponseOfUnit> {
        let url_ = this.baseUrl + "/api/Account/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfUnit>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfUnit>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<ResponseOfUnit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfUnit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfUnit>(<any>null);
    }

    getProfile(requestId: string | null | undefined) : Observable<ResponseOfAccountDto> {
        let url_ = this.baseUrl + "/api/Account/GetProfile?";
        if (requestId !== undefined && requestId !== null)
            url_ += "requestId=" + encodeURIComponent("" + requestId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfile(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfAccountDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfAccountDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfile(response: HttpResponseBase): Observable<ResponseOfAccountDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfAccountDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfAccountDto>(<any>null);
    }

    refreshToken(command: RefreshTokenCommand) : Observable<ResponseOfSignInResultDto> {
        let url_ = this.baseUrl + "/api/Account/RefreshToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshToken(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfSignInResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfSignInResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processRefreshToken(response: HttpResponseBase): Observable<ResponseOfSignInResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfSignInResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfSignInResultDto>(<any>null);
    }

    facebookLogin(command: FacebookLoginCommand) : Observable<ResponseOfSignInResultDto> {
        let url_ = this.baseUrl + "/api/Account/FacebookLogin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFacebookLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFacebookLogin(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfSignInResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfSignInResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processFacebookLogin(response: HttpResponseBase): Observable<ResponseOfSignInResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfSignInResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfSignInResultDto>(<any>null);
    }

    googleLogin(command: GoogleLoginCommand) : Observable<ResponseOfSignInResultDto> {
        let url_ = this.baseUrl + "/api/Account/GoogleLogin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGoogleLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGoogleLogin(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfSignInResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfSignInResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGoogleLogin(response: HttpResponseBase): Observable<ResponseOfSignInResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfSignInResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfSignInResultDto>(<any>null);
    }
}

export interface ICacheClient {
    clearAll(): Observable<FileResponse>;
    clearByKey(key: string | null | undefined): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class CacheClient implements ICacheClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    clearAll() : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Cache/ClearAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearAll(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processClearAll(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    clearByKey(key: string | null | undefined) : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Cache/ClearByKey?";
        if (key !== undefined && key !== null)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearByKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearByKey(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processClearByKey(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface ICountriesClient {
    get(id: number): Observable<ResponseOfCountryDto>;
    getList(keyword: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined, requestId: string | null | undefined): Observable<ResponseOfPaginatedListOfCountryDto>;
    create(command: CreateCountryCommand): Observable<ResponseOfInteger>;
    update(command: UpdateCountryCommand): Observable<ResponseOfUnit>;
    delete(id: number): Observable<ResponseOfUnit>;
}

@Injectable({
    providedIn: 'root'
})
export class CountriesClient implements ICountriesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(id: number) : Observable<ResponseOfCountryDto> {
        let url_ = this.baseUrl + "/api/Countries/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfCountryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfCountryDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ResponseOfCountryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfCountryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfCountryDto>(<any>null);
    }

    getList(keyword: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined, requestId: string | null | undefined) : Observable<ResponseOfPaginatedListOfCountryDto> {
        let url_ = this.baseUrl + "/api/Countries/GetList?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (requestId !== undefined && requestId !== null)
            url_ += "requestId=" + encodeURIComponent("" + requestId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfPaginatedListOfCountryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfPaginatedListOfCountryDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<ResponseOfPaginatedListOfCountryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfPaginatedListOfCountryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfPaginatedListOfCountryDto>(<any>null);
    }

    create(command: CreateCountryCommand) : Observable<ResponseOfInteger> {
        let url_ = this.baseUrl + "/api/Countries/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfInteger>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfInteger>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ResponseOfInteger> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfInteger.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfInteger>(<any>null);
    }

    update(command: UpdateCountryCommand) : Observable<ResponseOfUnit> {
        let url_ = this.baseUrl + "/api/Countries/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfUnit>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfUnit>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ResponseOfUnit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfUnit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfUnit>(<any>null);
    }

    delete(id: number) : Observable<ResponseOfUnit> {
        let url_ = this.baseUrl + "/api/Countries/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfUnit>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfUnit>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ResponseOfUnit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfUnit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfUnit>(<any>null);
    }
}

export interface IProvincesClient {
    get(id: number): Observable<ResponseOfProvinceDto>;
    getList(keyword: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined, requestId: string | null | undefined): Observable<ResponseOfPaginatedListOfProvinceDto>;
    create(command: CreateProvinceCommand): Observable<ResponseOfInteger>;
    update(command: UpdateProvinceCommand): Observable<ResponseOfUnit>;
    delete(id: number): Observable<ResponseOfUnit>;
}

@Injectable({
    providedIn: 'root'
})
export class ProvincesClient implements IProvincesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(id: number) : Observable<ResponseOfProvinceDto> {
        let url_ = this.baseUrl + "/api/Provinces/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfProvinceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfProvinceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ResponseOfProvinceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfProvinceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfProvinceDto>(<any>null);
    }

    getList(keyword: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined, requestId: string | null | undefined) : Observable<ResponseOfPaginatedListOfProvinceDto> {
        let url_ = this.baseUrl + "/api/Provinces/GetList?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (requestId !== undefined && requestId !== null)
            url_ += "requestId=" + encodeURIComponent("" + requestId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfPaginatedListOfProvinceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfPaginatedListOfProvinceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<ResponseOfPaginatedListOfProvinceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfPaginatedListOfProvinceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfPaginatedListOfProvinceDto>(<any>null);
    }

    create(command: CreateProvinceCommand) : Observable<ResponseOfInteger> {
        let url_ = this.baseUrl + "/api/Provinces/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfInteger>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfInteger>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ResponseOfInteger> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfInteger.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfInteger>(<any>null);
    }

    update(command: UpdateProvinceCommand) : Observable<ResponseOfUnit> {
        let url_ = this.baseUrl + "/api/Provinces/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfUnit>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfUnit>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ResponseOfUnit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfUnit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfUnit>(<any>null);
    }

    delete(id: number) : Observable<ResponseOfUnit> {
        let url_ = this.baseUrl + "/api/Provinces/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfUnit>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfUnit>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ResponseOfUnit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfUnit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfUnit>(<any>null);
    }
}

export interface ISystemClient {
    rSAEncryptData(request: EncryptedDataRequestModel): Observable<FileResponse>;
    getConfigs(): Observable<ResponseOfConfigsDto>;
}

@Injectable({
    providedIn: 'root'
})
export class SystemClient implements ISystemClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    rSAEncryptData(request: EncryptedDataRequestModel) : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/System/RSAEncryptData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRSAEncryptData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRSAEncryptData(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processRSAEncryptData(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getConfigs() : Observable<ResponseOfConfigsDto> {
        let url_ = this.baseUrl + "/api/System/GetConfigs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfigs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfigs(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfConfigsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfConfigsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfigs(response: HttpResponseBase): Observable<ResponseOfConfigsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfConfigsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfConfigsDto>(<any>null);
    }
}

export interface IWeatherClient {
    getForecastWeatherIn7Days(provinceId: number | undefined, requestId: string | null | undefined): Observable<ResponseOfWeatherForecastDto>;
    getLastLocalHistoricalWeatherQuery(provinceId: number | undefined, currentDt: number | undefined, noOfYearToGet: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, requestId: string | null | undefined): Observable<ResponseOfPaginatedListOfDailyForecastWeatherDto>;
    updateOrCreateWeatherData(request: UpdateOrCreateWeatherDataCommand): Observable<ResponseOfInteger>;
    delete(request: DeleteWeatherDataCommand): Observable<ResponseOfUnit>;
    getWeatherConditions(requestId: string | null | undefined): Observable<ResponseOfWeatherConditionCollectionDto>;
}

@Injectable({
    providedIn: 'root'
})
export class WeatherClient implements IWeatherClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getForecastWeatherIn7Days(provinceId: number | undefined, requestId: string | null | undefined) : Observable<ResponseOfWeatherForecastDto> {
        let url_ = this.baseUrl + "/api/Weather/GetForecastWeatherIn7Days?";
        if (provinceId === null)
            throw new Error("The parameter 'provinceId' cannot be null.");
        else if (provinceId !== undefined)
            url_ += "ProvinceId=" + encodeURIComponent("" + provinceId) + "&";
        if (requestId !== undefined && requestId !== null)
            url_ += "requestId=" + encodeURIComponent("" + requestId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForecastWeatherIn7Days(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForecastWeatherIn7Days(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfWeatherForecastDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfWeatherForecastDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetForecastWeatherIn7Days(response: HttpResponseBase): Observable<ResponseOfWeatherForecastDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfWeatherForecastDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfWeatherForecastDto>(<any>null);
    }

    getLastLocalHistoricalWeatherQuery(provinceId: number | undefined, currentDt: number | undefined, noOfYearToGet: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, requestId: string | null | undefined) : Observable<ResponseOfPaginatedListOfDailyForecastWeatherDto> {
        let url_ = this.baseUrl + "/api/Weather/GetLastLocalHistoricalWeatherQuery?";
        if (provinceId === null)
            throw new Error("The parameter 'provinceId' cannot be null.");
        else if (provinceId !== undefined)
            url_ += "ProvinceId=" + encodeURIComponent("" + provinceId) + "&";
        if (currentDt === null)
            throw new Error("The parameter 'currentDt' cannot be null.");
        else if (currentDt !== undefined)
            url_ += "CurrentDt=" + encodeURIComponent("" + currentDt) + "&";
        if (noOfYearToGet === null)
            throw new Error("The parameter 'noOfYearToGet' cannot be null.");
        else if (noOfYearToGet !== undefined)
            url_ += "NoOfYearToGet=" + encodeURIComponent("" + noOfYearToGet) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (requestId !== undefined && requestId !== null)
            url_ += "requestId=" + encodeURIComponent("" + requestId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLastLocalHistoricalWeatherQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLastLocalHistoricalWeatherQuery(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfPaginatedListOfDailyForecastWeatherDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfPaginatedListOfDailyForecastWeatherDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLastLocalHistoricalWeatherQuery(response: HttpResponseBase): Observable<ResponseOfPaginatedListOfDailyForecastWeatherDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfPaginatedListOfDailyForecastWeatherDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfPaginatedListOfDailyForecastWeatherDto>(<any>null);
    }

    updateOrCreateWeatherData(request: UpdateOrCreateWeatherDataCommand) : Observable<ResponseOfInteger> {
        let url_ = this.baseUrl + "/api/Weather/UpdateOrCreateWeatherData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrCreateWeatherData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrCreateWeatherData(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfInteger>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfInteger>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOrCreateWeatherData(response: HttpResponseBase): Observable<ResponseOfInteger> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfInteger.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfInteger>(<any>null);
    }

    delete(request: DeleteWeatherDataCommand) : Observable<ResponseOfUnit> {
        let url_ = this.baseUrl + "/api/Weather/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfUnit>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfUnit>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ResponseOfUnit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfUnit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfUnit>(<any>null);
    }

    getWeatherConditions(requestId: string | null | undefined) : Observable<ResponseOfWeatherConditionCollectionDto> {
        let url_ = this.baseUrl + "/api/Weather/GetWeatherConditions?";
        if (requestId !== undefined && requestId !== null)
            url_ += "requestId=" + encodeURIComponent("" + requestId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeatherConditions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeatherConditions(<any>response_);
                } catch (e) {
                    return <Observable<ResponseOfWeatherConditionCollectionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseOfWeatherConditionCollectionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeatherConditions(response: HttpResponseBase): Observable<ResponseOfWeatherConditionCollectionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOfWeatherConditionCollectionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseOfWeatherConditionCollectionDto>(<any>null);
    }
}

export class Response implements IResponse {
    succeeded?: boolean;
    message?: string | undefined;
    systemError?: string | undefined;
    title?: string | undefined;
    requestId?: string | undefined;
    requestTime?: string | undefined;
    responseTime?: string | undefined;

    constructor(data?: IResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.systemError = _data["systemError"];
            this.title = _data["title"];
            this.requestId = _data["requestId"];
            this.requestTime = _data["requestTime"];
            this.responseTime = _data["responseTime"];
        }
    }

    static fromJS(data: any): Response {
        data = typeof data === 'object' ? data : {};
        let result = new Response();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["systemError"] = this.systemError;
        data["title"] = this.title;
        data["requestId"] = this.requestId;
        data["requestTime"] = this.requestTime;
        data["responseTime"] = this.responseTime;
        return data; 
    }
}

export interface IResponse {
    succeeded?: boolean;
    message?: string | undefined;
    systemError?: string | undefined;
    title?: string | undefined;
    requestId?: string | undefined;
    requestTime?: string | undefined;
    responseTime?: string | undefined;
}

export class ResponseOfUnit extends Response implements IResponseOfUnit {
    data?: Unit;

    constructor(data?: IResponseOfUnit) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.data = _data["data"] ? Unit.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResponseOfUnit {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseOfUnit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IResponseOfUnit extends IResponse {
    data?: Unit;
}

/** Represents a void type, since Void is not a valid return type in C#. */
export class Unit implements IUnit {

    constructor(data?: IUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): Unit {
        data = typeof data === 'object' ? data : {};
        let result = new Unit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

/** Represents a void type, since Void is not a valid return type in C#. */
export interface IUnit {
}

export class SignUpCommand implements ISignUpCommand {
    email?: string | undefined;
    password?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    avatarUrl?: string | undefined;
    gender?: string | undefined;
    birthDay?: Date | undefined;
    address?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    zipCode?: string | undefined;
    country?: string | undefined;
    phone?: string | undefined;
    requestId?: string;

    constructor(data?: ISignUpCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.avatarUrl = _data["avatarUrl"];
            this.gender = _data["gender"];
            this.birthDay = _data["birthDay"] ? new Date(_data["birthDay"].toString()) : <any>undefined;
            this.address = _data["address"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.zipCode = _data["zipCode"];
            this.country = _data["country"];
            this.phone = _data["phone"];
            this.requestId = _data["requestId"];
        }
    }

    static fromJS(data: any): SignUpCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SignUpCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["avatarUrl"] = this.avatarUrl;
        data["gender"] = this.gender;
        data["birthDay"] = this.birthDay ? this.birthDay.toISOString() : <any>undefined;
        data["address"] = this.address;
        data["city"] = this.city;
        data["state"] = this.state;
        data["zipCode"] = this.zipCode;
        data["country"] = this.country;
        data["phone"] = this.phone;
        data["requestId"] = this.requestId;
        return data; 
    }
}

export interface ISignUpCommand {
    email?: string | undefined;
    password?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    avatarUrl?: string | undefined;
    gender?: string | undefined;
    birthDay?: Date | undefined;
    address?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    zipCode?: string | undefined;
    country?: string | undefined;
    phone?: string | undefined;
    requestId?: string;
}

export class ResponseOfSignInResultDto extends Response implements IResponseOfSignInResultDto {
    data?: SignInResultDto | undefined;

    constructor(data?: IResponseOfSignInResultDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.data = _data["data"] ? SignInResultDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResponseOfSignInResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseOfSignInResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IResponseOfSignInResultDto extends IResponse {
    data?: SignInResultDto | undefined;
}

export class SignInResultDto implements ISignInResultDto {
    accessToken?: string | undefined;
    account?: AccountDto | undefined;
    loginProvider?: string;

    constructor(data?: ISignInResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.account = _data["account"] ? AccountDto.fromJS(_data["account"]) : <any>undefined;
            this.loginProvider = _data["loginProvider"];
        }
    }

    static fromJS(data: any): SignInResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SignInResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["account"] = this.account ? this.account.toJSON() : <any>undefined;
        data["loginProvider"] = this.loginProvider;
        return data; 
    }
}

export interface ISignInResultDto {
    accessToken?: string | undefined;
    account?: AccountDto | undefined;
    loginProvider?: string;
}

export class AccountDto implements IAccountDto {
    id?: number;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    avatarUrl?: string | undefined;
    gender?: string | undefined;
    birthDay?: Date | undefined;
    address?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    zipCode?: string | undefined;
    country?: string | undefined;
    phone?: string | undefined;
    isFirstLogin?: boolean;
    roles?: string[];

    constructor(data?: IAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.avatarUrl = _data["avatarUrl"];
            this.gender = _data["gender"];
            this.birthDay = _data["birthDay"] ? new Date(_data["birthDay"].toString()) : <any>undefined;
            this.address = _data["address"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.zipCode = _data["zipCode"];
            this.country = _data["country"];
            this.phone = _data["phone"];
            this.isFirstLogin = _data["isFirstLogin"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): AccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["avatarUrl"] = this.avatarUrl;
        data["gender"] = this.gender;
        data["birthDay"] = this.birthDay ? this.birthDay.toISOString() : <any>undefined;
        data["address"] = this.address;
        data["city"] = this.city;
        data["state"] = this.state;
        data["zipCode"] = this.zipCode;
        data["country"] = this.country;
        data["phone"] = this.phone;
        data["isFirstLogin"] = this.isFirstLogin;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data; 
    }
}

export interface IAccountDto {
    id?: number;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    avatarUrl?: string | undefined;
    gender?: string | undefined;
    birthDay?: Date | undefined;
    address?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    zipCode?: string | undefined;
    country?: string | undefined;
    phone?: string | undefined;
    isFirstLogin?: boolean;
    roles?: string[];
}

export class SignInCommand implements ISignInCommand {
    email?: string;
    password?: string;
    keepLogin?: boolean;
    recaptchaToken?: string | undefined;
    requestId?: string;

    constructor(data?: ISignInCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.keepLogin = _data["keepLogin"];
            this.recaptchaToken = _data["recaptchaToken"];
            this.requestId = _data["requestId"];
        }
    }

    static fromJS(data: any): SignInCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SignInCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["keepLogin"] = this.keepLogin;
        data["recaptchaToken"] = this.recaptchaToken;
        data["requestId"] = this.requestId;
        return data; 
    }
}

export interface ISignInCommand {
    email?: string;
    password?: string;
    keepLogin?: boolean;
    recaptchaToken?: string | undefined;
    requestId?: string;
}

export class ActivationCommand implements IActivationCommand {
    code?: string | undefined;
    requestId?: string;

    constructor(data?: IActivationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestId = _data["requestId"];
        }
    }

    static fromJS(data: any): ActivationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ActivationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestId"] = this.requestId;
        return data; 
    }
}

export interface IActivationCommand {
    code?: string | undefined;
    requestId?: string;
}

export class ResponseOfEmailVerificationCodeResultDto extends Response implements IResponseOfEmailVerificationCodeResultDto {
    data?: EmailVerificationCodeResultDto | undefined;

    constructor(data?: IResponseOfEmailVerificationCodeResultDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.data = _data["data"] ? EmailVerificationCodeResultDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResponseOfEmailVerificationCodeResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseOfEmailVerificationCodeResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IResponseOfEmailVerificationCodeResultDto extends IResponse {
    data?: EmailVerificationCodeResultDto | undefined;
}

export class EmailVerificationCodeResultDto implements IEmailVerificationCodeResultDto {
    expireInSeconds?: number;

    constructor(data?: IEmailVerificationCodeResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.expireInSeconds = _data["expireInSeconds"];
        }
    }

    static fromJS(data: any): EmailVerificationCodeResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailVerificationCodeResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expireInSeconds"] = this.expireInSeconds;
        return data; 
    }
}

export interface IEmailVerificationCodeResultDto {
    expireInSeconds?: number;
}

export class GetEmailVerificationCodeCommand implements IGetEmailVerificationCodeCommand {
    email?: string | undefined;
    requestId?: string;

    constructor(data?: IGetEmailVerificationCodeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.requestId = _data["requestId"];
        }
    }

    static fromJS(data: any): GetEmailVerificationCodeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new GetEmailVerificationCodeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["requestId"] = this.requestId;
        return data; 
    }
}

export interface IGetEmailVerificationCodeCommand {
    email?: string | undefined;
    requestId?: string;
}

export class SignInByEmailVerificationCodeCommand implements ISignInByEmailVerificationCodeCommand {
    email?: string;
    code?: string;
    recaptchaToken?: string | undefined;
    requestId?: string;

    constructor(data?: ISignInByEmailVerificationCodeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.code = _data["code"];
            this.recaptchaToken = _data["recaptchaToken"];
            this.requestId = _data["requestId"];
        }
    }

    static fromJS(data: any): SignInByEmailVerificationCodeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SignInByEmailVerificationCodeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["code"] = this.code;
        data["recaptchaToken"] = this.recaptchaToken;
        data["requestId"] = this.requestId;
        return data; 
    }
}

export interface ISignInByEmailVerificationCodeCommand {
    email?: string;
    code?: string;
    recaptchaToken?: string | undefined;
    requestId?: string;
}

export class GetEmailResetPasswordCommand implements IGetEmailResetPasswordCommand {
    email?: string | undefined;
    recaptchaToken?: string | undefined;
    requestId?: string;

    constructor(data?: IGetEmailResetPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.recaptchaToken = _data["recaptchaToken"];
            this.requestId = _data["requestId"];
        }
    }

    static fromJS(data: any): GetEmailResetPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new GetEmailResetPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["recaptchaToken"] = this.recaptchaToken;
        data["requestId"] = this.requestId;
        return data; 
    }
}

export interface IGetEmailResetPasswordCommand {
    email?: string | undefined;
    recaptchaToken?: string | undefined;
    requestId?: string;
}

export class ResetPasswordCommand implements IResetPasswordCommand {
    code?: string | undefined;
    newPassword?: string | undefined;
    requestId?: string;

    constructor(data?: IResetPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.newPassword = _data["newPassword"];
            this.requestId = _data["requestId"];
        }
    }

    static fromJS(data: any): ResetPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["newPassword"] = this.newPassword;
        data["requestId"] = this.requestId;
        return data; 
    }
}

export interface IResetPasswordCommand {
    code?: string | undefined;
    newPassword?: string | undefined;
    requestId?: string;
}

export class ResponseOfAccountDto extends Response implements IResponseOfAccountDto {
    data?: AccountDto | undefined;

    constructor(data?: IResponseOfAccountDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.data = _data["data"] ? AccountDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResponseOfAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseOfAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IResponseOfAccountDto extends IResponse {
    data?: AccountDto | undefined;
}

export class RefreshTokenCommand implements IRefreshTokenCommand {
    accessToken?: string | undefined;
    requestId?: string;

    constructor(data?: IRefreshTokenCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.requestId = _data["requestId"];
        }
    }

    static fromJS(data: any): RefreshTokenCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["requestId"] = this.requestId;
        return data; 
    }
}

export interface IRefreshTokenCommand {
    accessToken?: string | undefined;
    requestId?: string;
}

export class FacebookLoginCommand implements IFacebookLoginCommand {
    access_Token?: string;
    requestId?: string;

    constructor(data?: IFacebookLoginCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.access_Token = _data["access_Token"];
            this.requestId = _data["requestId"];
        }
    }

    static fromJS(data: any): FacebookLoginCommand {
        data = typeof data === 'object' ? data : {};
        let result = new FacebookLoginCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["access_Token"] = this.access_Token;
        data["requestId"] = this.requestId;
        return data; 
    }
}

export interface IFacebookLoginCommand {
    access_Token?: string;
    requestId?: string;
}

export class GoogleLoginCommand implements IGoogleLoginCommand {
    access_Token?: string;
    requestId?: string;

    constructor(data?: IGoogleLoginCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.access_Token = _data["access_Token"];
            this.requestId = _data["requestId"];
        }
    }

    static fromJS(data: any): GoogleLoginCommand {
        data = typeof data === 'object' ? data : {};
        let result = new GoogleLoginCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["access_Token"] = this.access_Token;
        data["requestId"] = this.requestId;
        return data; 
    }
}

export interface IGoogleLoginCommand {
    access_Token?: string;
    requestId?: string;
}

export class ResponseOfCountryDto extends Response implements IResponseOfCountryDto {
    data?: CountryDto | undefined;

    constructor(data?: IResponseOfCountryDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.data = _data["data"] ? CountryDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResponseOfCountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseOfCountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IResponseOfCountryDto extends IResponse {
    data?: CountryDto | undefined;
}

export class CountryDto implements ICountryDto {
    id?: number;
    name?: string | undefined;
    priority?: number;
    languageCode?: string | undefined;
    iconUrl?: string | undefined;
    userDefined1?: string | undefined;
    userDefined2?: string | undefined;
    userDefined3?: string | undefined;
    provinces?: ProvinceDto[];

    constructor(data?: ICountryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.priority = _data["priority"];
            this.languageCode = _data["languageCode"];
            this.iconUrl = _data["iconUrl"];
            this.userDefined1 = _data["userDefined1"];
            this.userDefined2 = _data["userDefined2"];
            this.userDefined3 = _data["userDefined3"];
            if (Array.isArray(_data["provinces"])) {
                this.provinces = [] as any;
                for (let item of _data["provinces"])
                    this.provinces!.push(ProvinceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["priority"] = this.priority;
        data["languageCode"] = this.languageCode;
        data["iconUrl"] = this.iconUrl;
        data["userDefined1"] = this.userDefined1;
        data["userDefined2"] = this.userDefined2;
        data["userDefined3"] = this.userDefined3;
        if (Array.isArray(this.provinces)) {
            data["provinces"] = [];
            for (let item of this.provinces)
                data["provinces"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICountryDto {
    id?: number;
    name?: string | undefined;
    priority?: number;
    languageCode?: string | undefined;
    iconUrl?: string | undefined;
    userDefined1?: string | undefined;
    userDefined2?: string | undefined;
    userDefined3?: string | undefined;
    provinces?: ProvinceDto[];
}

export class ProvinceDto implements IProvinceDto {
    id?: number;
    name?: string | undefined;
    aliasName?: string | undefined;
    longitude?: number | undefined;
    latitude?: number | undefined;
    priority?: number;
    countryId?: number | undefined;

    constructor(data?: IProvinceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.aliasName = _data["aliasName"];
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
            this.priority = _data["priority"];
            this.countryId = _data["countryId"];
        }
    }

    static fromJS(data: any): ProvinceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProvinceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["aliasName"] = this.aliasName;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        data["priority"] = this.priority;
        data["countryId"] = this.countryId;
        return data; 
    }
}

export interface IProvinceDto {
    id?: number;
    name?: string | undefined;
    aliasName?: string | undefined;
    longitude?: number | undefined;
    latitude?: number | undefined;
    priority?: number;
    countryId?: number | undefined;
}

export class ResponseOfPaginatedListOfCountryDto extends Response implements IResponseOfPaginatedListOfCountryDto {
    data?: PaginatedListOfCountryDto | undefined;

    constructor(data?: IResponseOfPaginatedListOfCountryDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.data = _data["data"] ? PaginatedListOfCountryDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResponseOfPaginatedListOfCountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseOfPaginatedListOfCountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IResponseOfPaginatedListOfCountryDto extends IResponse {
    data?: PaginatedListOfCountryDto | undefined;
}

export class PaginatedListOfCountryDto implements IPaginatedListOfCountryDto {
    items?: CountryDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfCountryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CountryDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfCountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfCountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IPaginatedListOfCountryDto {
    items?: CountryDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ResponseOfInteger extends Response implements IResponseOfInteger {
    data?: number;

    constructor(data?: IResponseOfInteger) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): ResponseOfInteger {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseOfInteger();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        super.toJSON(data);
        return data; 
    }
}

export interface IResponseOfInteger extends IResponse {
    data?: number;
}

export class CreateCountryCommand implements ICreateCountryCommand {
    name?: string | undefined;
    priority?: number;
    languageCode?: string | undefined;
    iconUrl?: string | undefined;
    userDefined1?: string | undefined;
    userDefined2?: string | undefined;
    userDefined3?: string | undefined;
    requestId?: string;

    constructor(data?: ICreateCountryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.priority = _data["priority"];
            this.languageCode = _data["languageCode"];
            this.iconUrl = _data["iconUrl"];
            this.userDefined1 = _data["userDefined1"];
            this.userDefined2 = _data["userDefined2"];
            this.userDefined3 = _data["userDefined3"];
            this.requestId = _data["requestId"];
        }
    }

    static fromJS(data: any): CreateCountryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCountryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["priority"] = this.priority;
        data["languageCode"] = this.languageCode;
        data["iconUrl"] = this.iconUrl;
        data["userDefined1"] = this.userDefined1;
        data["userDefined2"] = this.userDefined2;
        data["userDefined3"] = this.userDefined3;
        data["requestId"] = this.requestId;
        return data; 
    }
}

export interface ICreateCountryCommand {
    name?: string | undefined;
    priority?: number;
    languageCode?: string | undefined;
    iconUrl?: string | undefined;
    userDefined1?: string | undefined;
    userDefined2?: string | undefined;
    userDefined3?: string | undefined;
    requestId?: string;
}

export class UpdateCountryCommand implements IUpdateCountryCommand {
    id?: number;
    name?: string | undefined;
    priority?: number;
    languageCode?: string | undefined;
    iconUrl?: string | undefined;
    userDefined1?: string | undefined;
    userDefined2?: string | undefined;
    userDefined3?: string | undefined;
    requestId?: string;

    constructor(data?: IUpdateCountryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.priority = _data["priority"];
            this.languageCode = _data["languageCode"];
            this.iconUrl = _data["iconUrl"];
            this.userDefined1 = _data["userDefined1"];
            this.userDefined2 = _data["userDefined2"];
            this.userDefined3 = _data["userDefined3"];
            this.requestId = _data["requestId"];
        }
    }

    static fromJS(data: any): UpdateCountryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCountryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["priority"] = this.priority;
        data["languageCode"] = this.languageCode;
        data["iconUrl"] = this.iconUrl;
        data["userDefined1"] = this.userDefined1;
        data["userDefined2"] = this.userDefined2;
        data["userDefined3"] = this.userDefined3;
        data["requestId"] = this.requestId;
        return data; 
    }
}

export interface IUpdateCountryCommand {
    id?: number;
    name?: string | undefined;
    priority?: number;
    languageCode?: string | undefined;
    iconUrl?: string | undefined;
    userDefined1?: string | undefined;
    userDefined2?: string | undefined;
    userDefined3?: string | undefined;
    requestId?: string;
}

export class ResponseOfProvinceDto extends Response implements IResponseOfProvinceDto {
    data?: ProvinceDto | undefined;

    constructor(data?: IResponseOfProvinceDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.data = _data["data"] ? ProvinceDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResponseOfProvinceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseOfProvinceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IResponseOfProvinceDto extends IResponse {
    data?: ProvinceDto | undefined;
}

export class ResponseOfPaginatedListOfProvinceDto extends Response implements IResponseOfPaginatedListOfProvinceDto {
    data?: PaginatedListOfProvinceDto | undefined;

    constructor(data?: IResponseOfPaginatedListOfProvinceDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.data = _data["data"] ? PaginatedListOfProvinceDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResponseOfPaginatedListOfProvinceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseOfPaginatedListOfProvinceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IResponseOfPaginatedListOfProvinceDto extends IResponse {
    data?: PaginatedListOfProvinceDto | undefined;
}

export class PaginatedListOfProvinceDto implements IPaginatedListOfProvinceDto {
    items?: ProvinceDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfProvinceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProvinceDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfProvinceDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfProvinceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IPaginatedListOfProvinceDto {
    items?: ProvinceDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class CreateProvinceCommand implements ICreateProvinceCommand {
    name?: string | undefined;
    longitude?: number | undefined;
    latitude?: number | undefined;
    priority?: number;
    aliasName?: string | undefined;
    countryId?: number | undefined;
    requestId?: string;

    constructor(data?: ICreateProvinceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
            this.priority = _data["priority"];
            this.aliasName = _data["aliasName"];
            this.countryId = _data["countryId"];
            this.requestId = _data["requestId"];
        }
    }

    static fromJS(data: any): CreateProvinceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProvinceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        data["priority"] = this.priority;
        data["aliasName"] = this.aliasName;
        data["countryId"] = this.countryId;
        data["requestId"] = this.requestId;
        return data; 
    }
}

export interface ICreateProvinceCommand {
    name?: string | undefined;
    longitude?: number | undefined;
    latitude?: number | undefined;
    priority?: number;
    aliasName?: string | undefined;
    countryId?: number | undefined;
    requestId?: string;
}

export class UpdateProvinceCommand implements IUpdateProvinceCommand {
    id?: number;
    name?: string | undefined;
    longitude?: number | undefined;
    latitude?: number | undefined;
    priority?: number;
    aliasName?: string | undefined;
    countryId?: number | undefined;
    requestId?: string;

    constructor(data?: IUpdateProvinceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
            this.priority = _data["priority"];
            this.aliasName = _data["aliasName"];
            this.countryId = _data["countryId"];
            this.requestId = _data["requestId"];
        }
    }

    static fromJS(data: any): UpdateProvinceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProvinceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        data["priority"] = this.priority;
        data["aliasName"] = this.aliasName;
        data["countryId"] = this.countryId;
        data["requestId"] = this.requestId;
        return data; 
    }
}

export interface IUpdateProvinceCommand {
    id?: number;
    name?: string | undefined;
    longitude?: number | undefined;
    latitude?: number | undefined;
    priority?: number;
    aliasName?: string | undefined;
    countryId?: number | undefined;
    requestId?: string;
}

export class EncryptedDataRequestModel implements IEncryptedDataRequestModel {
    plainText1?: string | undefined;
    plainText2?: string | undefined;

    constructor(data?: IEncryptedDataRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.plainText1 = _data["plainText1"];
            this.plainText2 = _data["plainText2"];
        }
    }

    static fromJS(data: any): EncryptedDataRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new EncryptedDataRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["plainText1"] = this.plainText1;
        data["plainText2"] = this.plainText2;
        return data; 
    }
}

export interface IEncryptedDataRequestModel {
    plainText1?: string | undefined;
    plainText2?: string | undefined;
}

export class ResponseOfConfigsDto extends Response implements IResponseOfConfigsDto {
    data?: ConfigsDto | undefined;

    constructor(data?: IResponseOfConfigsDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.data = _data["data"] ? ConfigsDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResponseOfConfigsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseOfConfigsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IResponseOfConfigsDto extends IResponse {
    data?: ConfigsDto | undefined;
}

export class ConfigsDto implements IConfigsDto {
    version?: string | undefined;
    enableEncryptAuthorize?: boolean;
    publicKeyEncode?: string | undefined;
    enableGoogleReCaptcha?: boolean;
    googleRecaptchaVersion?: string | undefined;
    googleSiteKey?: string | undefined;
    facebook_AppId?: string | undefined;
    facebook_AppVer?: string | undefined;
    google_ClientID?: string | undefined;

    constructor(data?: IConfigsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.enableEncryptAuthorize = _data["enableEncryptAuthorize"];
            this.publicKeyEncode = _data["publicKeyEncode"];
            this.enableGoogleReCaptcha = _data["enableGoogleReCaptcha"];
            this.googleRecaptchaVersion = _data["googleRecaptchaVersion"];
            this.googleSiteKey = _data["googleSiteKey"];
            this.facebook_AppId = _data["facebook_AppId"];
            this.facebook_AppVer = _data["facebook_AppVer"];
            this.google_ClientID = _data["google_ClientID"];
        }
    }

    static fromJS(data: any): ConfigsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConfigsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["enableEncryptAuthorize"] = this.enableEncryptAuthorize;
        data["publicKeyEncode"] = this.publicKeyEncode;
        data["enableGoogleReCaptcha"] = this.enableGoogleReCaptcha;
        data["googleRecaptchaVersion"] = this.googleRecaptchaVersion;
        data["googleSiteKey"] = this.googleSiteKey;
        data["facebook_AppId"] = this.facebook_AppId;
        data["facebook_AppVer"] = this.facebook_AppVer;
        data["google_ClientID"] = this.google_ClientID;
        return data; 
    }
}

export interface IConfigsDto {
    version?: string | undefined;
    enableEncryptAuthorize?: boolean;
    publicKeyEncode?: string | undefined;
    enableGoogleReCaptcha?: boolean;
    googleRecaptchaVersion?: string | undefined;
    googleSiteKey?: string | undefined;
    facebook_AppId?: string | undefined;
    facebook_AppVer?: string | undefined;
    google_ClientID?: string | undefined;
}

export class ResponseOfWeatherForecastDto extends Response implements IResponseOfWeatherForecastDto {
    data?: WeatherForecastDto | undefined;

    constructor(data?: IResponseOfWeatherForecastDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.data = _data["data"] ? WeatherForecastDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResponseOfWeatherForecastDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseOfWeatherForecastDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IResponseOfWeatherForecastDto extends IResponse {
    data?: WeatherForecastDto | undefined;
}

export class WeatherForecastDto implements IWeatherForecastDto {
    daily?: DailyForecastWeatherDto[];
    hourly?: HourlyForecastWeatherDto[];

    constructor(data?: IWeatherForecastDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["daily"])) {
                this.daily = [] as any;
                for (let item of _data["daily"])
                    this.daily!.push(DailyForecastWeatherDto.fromJS(item));
            }
            if (Array.isArray(_data["hourly"])) {
                this.hourly = [] as any;
                for (let item of _data["hourly"])
                    this.hourly!.push(HourlyForecastWeatherDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WeatherForecastDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecastDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.daily)) {
            data["daily"] = [];
            for (let item of this.daily)
                data["daily"].push(item.toJSON());
        }
        if (Array.isArray(this.hourly)) {
            data["hourly"] = [];
            for (let item of this.hourly)
                data["hourly"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IWeatherForecastDto {
    daily?: DailyForecastWeatherDto[];
    hourly?: HourlyForecastWeatherDto[];
}

export class DailyForecastWeatherDto implements IDailyForecastWeatherDto {
    id?: number;
    dt?: number;
    sunrise?: number;
    sunset?: number;
    temp_avg?: number;
    temp_min?: number;
    temp_max?: number;
    humidity?: number;
    dew_point?: number;
    pop?: number;
    wind_speed?: number;
    clouds?: number;
    weather_id?: number;
    weather_main?: string | undefined;
    weather_description?: string | undefined;
    weather_icon?: string | undefined;
    temp_morn?: number;
    temp_day?: number;
    temp_eve?: number;
    temp_night?: number;
    weatherId_morn?: number;
    weatherMain_morn?: string | undefined;
    weatherDesc_morn?: string | undefined;
    weatherIcon_morn?: string | undefined;
    weatherId_day?: number;
    weatherMain_day?: string | undefined;
    weatherDesc_day?: string | undefined;
    weatherIcon_day?: string | undefined;
    weatherId_eve?: number;
    weatherMain_eve?: string | undefined;
    weatherDesc_eve?: string | undefined;
    weatherIcon_eve?: string | undefined;
    weatherId_night?: number;
    weatherMain_night?: string | undefined;
    weatherDesc_night?: string | undefined;
    weatherIcon_night?: string | undefined;
    weather_icon_url?: string;
    weatherIcon_morn_url?: string;
    weatherIcon_day_url?: string;
    weatherIcon_eve_url?: string;
    weatherIcon_night_url?: string;

    constructor(data?: IDailyForecastWeatherDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dt = _data["dt"];
            this.sunrise = _data["sunrise"];
            this.sunset = _data["sunset"];
            this.temp_avg = _data["temp_avg"];
            this.temp_min = _data["temp_min"];
            this.temp_max = _data["temp_max"];
            this.humidity = _data["humidity"];
            this.dew_point = _data["dew_point"];
            this.pop = _data["pop"];
            this.wind_speed = _data["wind_speed"];
            this.clouds = _data["clouds"];
            this.weather_id = _data["weather_id"];
            this.weather_main = _data["weather_main"];
            this.weather_description = _data["weather_description"];
            this.weather_icon = _data["weather_icon"];
            this.temp_morn = _data["temp_morn"];
            this.temp_day = _data["temp_day"];
            this.temp_eve = _data["temp_eve"];
            this.temp_night = _data["temp_night"];
            this.weatherId_morn = _data["weatherId_morn"];
            this.weatherMain_morn = _data["weatherMain_morn"];
            this.weatherDesc_morn = _data["weatherDesc_morn"];
            this.weatherIcon_morn = _data["weatherIcon_morn"];
            this.weatherId_day = _data["weatherId_day"];
            this.weatherMain_day = _data["weatherMain_day"];
            this.weatherDesc_day = _data["weatherDesc_day"];
            this.weatherIcon_day = _data["weatherIcon_day"];
            this.weatherId_eve = _data["weatherId_eve"];
            this.weatherMain_eve = _data["weatherMain_eve"];
            this.weatherDesc_eve = _data["weatherDesc_eve"];
            this.weatherIcon_eve = _data["weatherIcon_eve"];
            this.weatherId_night = _data["weatherId_night"];
            this.weatherMain_night = _data["weatherMain_night"];
            this.weatherDesc_night = _data["weatherDesc_night"];
            this.weatherIcon_night = _data["weatherIcon_night"];
            this.weather_icon_url = _data["weather_icon_url"];
            this.weatherIcon_morn_url = _data["weatherIcon_morn_url"];
            this.weatherIcon_day_url = _data["weatherIcon_day_url"];
            this.weatherIcon_eve_url = _data["weatherIcon_eve_url"];
            this.weatherIcon_night_url = _data["weatherIcon_night_url"];
        }
    }

    static fromJS(data: any): DailyForecastWeatherDto {
        data = typeof data === 'object' ? data : {};
        let result = new DailyForecastWeatherDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dt"] = this.dt;
        data["sunrise"] = this.sunrise;
        data["sunset"] = this.sunset;
        data["temp_avg"] = this.temp_avg;
        data["temp_min"] = this.temp_min;
        data["temp_max"] = this.temp_max;
        data["humidity"] = this.humidity;
        data["dew_point"] = this.dew_point;
        data["pop"] = this.pop;
        data["wind_speed"] = this.wind_speed;
        data["clouds"] = this.clouds;
        data["weather_id"] = this.weather_id;
        data["weather_main"] = this.weather_main;
        data["weather_description"] = this.weather_description;
        data["weather_icon"] = this.weather_icon;
        data["temp_morn"] = this.temp_morn;
        data["temp_day"] = this.temp_day;
        data["temp_eve"] = this.temp_eve;
        data["temp_night"] = this.temp_night;
        data["weatherId_morn"] = this.weatherId_morn;
        data["weatherMain_morn"] = this.weatherMain_morn;
        data["weatherDesc_morn"] = this.weatherDesc_morn;
        data["weatherIcon_morn"] = this.weatherIcon_morn;
        data["weatherId_day"] = this.weatherId_day;
        data["weatherMain_day"] = this.weatherMain_day;
        data["weatherDesc_day"] = this.weatherDesc_day;
        data["weatherIcon_day"] = this.weatherIcon_day;
        data["weatherId_eve"] = this.weatherId_eve;
        data["weatherMain_eve"] = this.weatherMain_eve;
        data["weatherDesc_eve"] = this.weatherDesc_eve;
        data["weatherIcon_eve"] = this.weatherIcon_eve;
        data["weatherId_night"] = this.weatherId_night;
        data["weatherMain_night"] = this.weatherMain_night;
        data["weatherDesc_night"] = this.weatherDesc_night;
        data["weatherIcon_night"] = this.weatherIcon_night;
        data["weather_icon_url"] = this.weather_icon_url;
        data["weatherIcon_morn_url"] = this.weatherIcon_morn_url;
        data["weatherIcon_day_url"] = this.weatherIcon_day_url;
        data["weatherIcon_eve_url"] = this.weatherIcon_eve_url;
        data["weatherIcon_night_url"] = this.weatherIcon_night_url;
        return data; 
    }
}

export interface IDailyForecastWeatherDto {
    id?: number;
    dt?: number;
    sunrise?: number;
    sunset?: number;
    temp_avg?: number;
    temp_min?: number;
    temp_max?: number;
    humidity?: number;
    dew_point?: number;
    pop?: number;
    wind_speed?: number;
    clouds?: number;
    weather_id?: number;
    weather_main?: string | undefined;
    weather_description?: string | undefined;
    weather_icon?: string | undefined;
    temp_morn?: number;
    temp_day?: number;
    temp_eve?: number;
    temp_night?: number;
    weatherId_morn?: number;
    weatherMain_morn?: string | undefined;
    weatherDesc_morn?: string | undefined;
    weatherIcon_morn?: string | undefined;
    weatherId_day?: number;
    weatherMain_day?: string | undefined;
    weatherDesc_day?: string | undefined;
    weatherIcon_day?: string | undefined;
    weatherId_eve?: number;
    weatherMain_eve?: string | undefined;
    weatherDesc_eve?: string | undefined;
    weatherIcon_eve?: string | undefined;
    weatherId_night?: number;
    weatherMain_night?: string | undefined;
    weatherDesc_night?: string | undefined;
    weatherIcon_night?: string | undefined;
    weather_icon_url?: string;
    weatherIcon_morn_url?: string;
    weatherIcon_day_url?: string;
    weatherIcon_eve_url?: string;
    weatherIcon_night_url?: string;
}

export class HourlyForecastWeatherDto implements IHourlyForecastWeatherDto {
    dt?: number;
    temp?: number;
    feels_like?: number;
    pressure?: number;
    humidity?: number;
    dew_point?: number;
    uvi?: number;
    clouds?: number;
    visibility?: number;
    wind_speed?: number;
    wind_deg?: number;
    wind_gust?: number;
    pop?: number;
    weather_id?: number;
    weather_main?: string | undefined;
    weather_description?: string | undefined;
    weather_icon?: string | undefined;
    weather_icon_url?: string;

    constructor(data?: IHourlyForecastWeatherDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dt = _data["dt"];
            this.temp = _data["temp"];
            this.feels_like = _data["feels_like"];
            this.pressure = _data["pressure"];
            this.humidity = _data["humidity"];
            this.dew_point = _data["dew_point"];
            this.uvi = _data["uvi"];
            this.clouds = _data["clouds"];
            this.visibility = _data["visibility"];
            this.wind_speed = _data["wind_speed"];
            this.wind_deg = _data["wind_deg"];
            this.wind_gust = _data["wind_gust"];
            this.pop = _data["pop"];
            this.weather_id = _data["weather_id"];
            this.weather_main = _data["weather_main"];
            this.weather_description = _data["weather_description"];
            this.weather_icon = _data["weather_icon"];
            this.weather_icon_url = _data["weather_icon_url"];
        }
    }

    static fromJS(data: any): HourlyForecastWeatherDto {
        data = typeof data === 'object' ? data : {};
        let result = new HourlyForecastWeatherDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dt"] = this.dt;
        data["temp"] = this.temp;
        data["feels_like"] = this.feels_like;
        data["pressure"] = this.pressure;
        data["humidity"] = this.humidity;
        data["dew_point"] = this.dew_point;
        data["uvi"] = this.uvi;
        data["clouds"] = this.clouds;
        data["visibility"] = this.visibility;
        data["wind_speed"] = this.wind_speed;
        data["wind_deg"] = this.wind_deg;
        data["wind_gust"] = this.wind_gust;
        data["pop"] = this.pop;
        data["weather_id"] = this.weather_id;
        data["weather_main"] = this.weather_main;
        data["weather_description"] = this.weather_description;
        data["weather_icon"] = this.weather_icon;
        data["weather_icon_url"] = this.weather_icon_url;
        return data; 
    }
}

export interface IHourlyForecastWeatherDto {
    dt?: number;
    temp?: number;
    feels_like?: number;
    pressure?: number;
    humidity?: number;
    dew_point?: number;
    uvi?: number;
    clouds?: number;
    visibility?: number;
    wind_speed?: number;
    wind_deg?: number;
    wind_gust?: number;
    pop?: number;
    weather_id?: number;
    weather_main?: string | undefined;
    weather_description?: string | undefined;
    weather_icon?: string | undefined;
    weather_icon_url?: string;
}

export class ResponseOfPaginatedListOfDailyForecastWeatherDto extends Response implements IResponseOfPaginatedListOfDailyForecastWeatherDto {
    data?: PaginatedListOfDailyForecastWeatherDto | undefined;

    constructor(data?: IResponseOfPaginatedListOfDailyForecastWeatherDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.data = _data["data"] ? PaginatedListOfDailyForecastWeatherDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResponseOfPaginatedListOfDailyForecastWeatherDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseOfPaginatedListOfDailyForecastWeatherDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IResponseOfPaginatedListOfDailyForecastWeatherDto extends IResponse {
    data?: PaginatedListOfDailyForecastWeatherDto | undefined;
}

export class PaginatedListOfDailyForecastWeatherDto implements IPaginatedListOfDailyForecastWeatherDto {
    items?: DailyForecastWeatherDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfDailyForecastWeatherDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DailyForecastWeatherDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfDailyForecastWeatherDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfDailyForecastWeatherDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IPaginatedListOfDailyForecastWeatherDto {
    items?: DailyForecastWeatherDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class UpdateOrCreateWeatherDataCommand implements IUpdateOrCreateWeatherDataCommand {
    id?: number;
    provinceId?: number;
    dt?: number;
    sunrise?: number;
    sunset?: number;
    temp_avg?: number;
    temp_min?: number;
    temp_max?: number;
    humidity?: number;
    dew_point?: number;
    pop?: number;
    wind_speed?: number;
    clouds?: number;
    weather_id?: number;
    weather_main?: string | undefined;
    weather_description?: string | undefined;
    weather_icon?: string | undefined;
    temp_morn?: number;
    temp_day?: number;
    temp_eve?: number;
    temp_night?: number;
    weatherId_morn?: number;
    weatherMain_morn?: string | undefined;
    weatherDesc_morn?: string | undefined;
    weatherIcon_morn?: string | undefined;
    weatherId_day?: number;
    weatherMain_day?: string | undefined;
    weatherDesc_day?: string | undefined;
    weatherIcon_day?: string | undefined;
    weatherId_eve?: number;
    weatherMain_eve?: string | undefined;
    weatherDesc_eve?: string | undefined;
    weatherIcon_eve?: string | undefined;
    weatherId_night?: number;
    weatherMain_night?: string | undefined;
    weatherDesc_night?: string | undefined;
    weatherIcon_night?: string | undefined;
    requestId?: string;

    constructor(data?: IUpdateOrCreateWeatherDataCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.provinceId = _data["provinceId"];
            this.dt = _data["dt"];
            this.sunrise = _data["sunrise"];
            this.sunset = _data["sunset"];
            this.temp_avg = _data["temp_avg"];
            this.temp_min = _data["temp_min"];
            this.temp_max = _data["temp_max"];
            this.humidity = _data["humidity"];
            this.dew_point = _data["dew_point"];
            this.pop = _data["pop"];
            this.wind_speed = _data["wind_speed"];
            this.clouds = _data["clouds"];
            this.weather_id = _data["weather_id"];
            this.weather_main = _data["weather_main"];
            this.weather_description = _data["weather_description"];
            this.weather_icon = _data["weather_icon"];
            this.temp_morn = _data["temp_morn"];
            this.temp_day = _data["temp_day"];
            this.temp_eve = _data["temp_eve"];
            this.temp_night = _data["temp_night"];
            this.weatherId_morn = _data["weatherId_morn"];
            this.weatherMain_morn = _data["weatherMain_morn"];
            this.weatherDesc_morn = _data["weatherDesc_morn"];
            this.weatherIcon_morn = _data["weatherIcon_morn"];
            this.weatherId_day = _data["weatherId_day"];
            this.weatherMain_day = _data["weatherMain_day"];
            this.weatherDesc_day = _data["weatherDesc_day"];
            this.weatherIcon_day = _data["weatherIcon_day"];
            this.weatherId_eve = _data["weatherId_eve"];
            this.weatherMain_eve = _data["weatherMain_eve"];
            this.weatherDesc_eve = _data["weatherDesc_eve"];
            this.weatherIcon_eve = _data["weatherIcon_eve"];
            this.weatherId_night = _data["weatherId_night"];
            this.weatherMain_night = _data["weatherMain_night"];
            this.weatherDesc_night = _data["weatherDesc_night"];
            this.weatherIcon_night = _data["weatherIcon_night"];
            this.requestId = _data["requestId"];
        }
    }

    static fromJS(data: any): UpdateOrCreateWeatherDataCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrCreateWeatherDataCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["provinceId"] = this.provinceId;
        data["dt"] = this.dt;
        data["sunrise"] = this.sunrise;
        data["sunset"] = this.sunset;
        data["temp_avg"] = this.temp_avg;
        data["temp_min"] = this.temp_min;
        data["temp_max"] = this.temp_max;
        data["humidity"] = this.humidity;
        data["dew_point"] = this.dew_point;
        data["pop"] = this.pop;
        data["wind_speed"] = this.wind_speed;
        data["clouds"] = this.clouds;
        data["weather_id"] = this.weather_id;
        data["weather_main"] = this.weather_main;
        data["weather_description"] = this.weather_description;
        data["weather_icon"] = this.weather_icon;
        data["temp_morn"] = this.temp_morn;
        data["temp_day"] = this.temp_day;
        data["temp_eve"] = this.temp_eve;
        data["temp_night"] = this.temp_night;
        data["weatherId_morn"] = this.weatherId_morn;
        data["weatherMain_morn"] = this.weatherMain_morn;
        data["weatherDesc_morn"] = this.weatherDesc_morn;
        data["weatherIcon_morn"] = this.weatherIcon_morn;
        data["weatherId_day"] = this.weatherId_day;
        data["weatherMain_day"] = this.weatherMain_day;
        data["weatherDesc_day"] = this.weatherDesc_day;
        data["weatherIcon_day"] = this.weatherIcon_day;
        data["weatherId_eve"] = this.weatherId_eve;
        data["weatherMain_eve"] = this.weatherMain_eve;
        data["weatherDesc_eve"] = this.weatherDesc_eve;
        data["weatherIcon_eve"] = this.weatherIcon_eve;
        data["weatherId_night"] = this.weatherId_night;
        data["weatherMain_night"] = this.weatherMain_night;
        data["weatherDesc_night"] = this.weatherDesc_night;
        data["weatherIcon_night"] = this.weatherIcon_night;
        data["requestId"] = this.requestId;
        return data; 
    }
}

export interface IUpdateOrCreateWeatherDataCommand {
    id?: number;
    provinceId?: number;
    dt?: number;
    sunrise?: number;
    sunset?: number;
    temp_avg?: number;
    temp_min?: number;
    temp_max?: number;
    humidity?: number;
    dew_point?: number;
    pop?: number;
    wind_speed?: number;
    clouds?: number;
    weather_id?: number;
    weather_main?: string | undefined;
    weather_description?: string | undefined;
    weather_icon?: string | undefined;
    temp_morn?: number;
    temp_day?: number;
    temp_eve?: number;
    temp_night?: number;
    weatherId_morn?: number;
    weatherMain_morn?: string | undefined;
    weatherDesc_morn?: string | undefined;
    weatherIcon_morn?: string | undefined;
    weatherId_day?: number;
    weatherMain_day?: string | undefined;
    weatherDesc_day?: string | undefined;
    weatherIcon_day?: string | undefined;
    weatherId_eve?: number;
    weatherMain_eve?: string | undefined;
    weatherDesc_eve?: string | undefined;
    weatherIcon_eve?: string | undefined;
    weatherId_night?: number;
    weatherMain_night?: string | undefined;
    weatherDesc_night?: string | undefined;
    weatherIcon_night?: string | undefined;
    requestId?: string;
}

export class DeleteWeatherDataCommand implements IDeleteWeatherDataCommand {
    id?: number;
    requestId?: string;

    constructor(data?: IDeleteWeatherDataCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.requestId = _data["requestId"];
        }
    }

    static fromJS(data: any): DeleteWeatherDataCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteWeatherDataCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["requestId"] = this.requestId;
        return data; 
    }
}

export interface IDeleteWeatherDataCommand {
    id?: number;
    requestId?: string;
}

export class ResponseOfWeatherConditionCollectionDto extends Response implements IResponseOfWeatherConditionCollectionDto {
    data?: WeatherConditionCollectionDto | undefined;

    constructor(data?: IResponseOfWeatherConditionCollectionDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.data = _data["data"] ? WeatherConditionCollectionDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResponseOfWeatherConditionCollectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseOfWeatherConditionCollectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IResponseOfWeatherConditionCollectionDto extends IResponse {
    data?: WeatherConditionCollectionDto | undefined;
}

export class WeatherConditionCollectionDto implements IWeatherConditionCollectionDto {
    weatherConditionGroups?: OWPWeatherConditionGroup[];
    weatherConditions?: OWPWeatherCondition[];
    weatherConditionsInNight?: OWPWeatherCondition[];

    constructor(data?: IWeatherConditionCollectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["weatherConditionGroups"])) {
                this.weatherConditionGroups = [] as any;
                for (let item of _data["weatherConditionGroups"])
                    this.weatherConditionGroups!.push(OWPWeatherConditionGroup.fromJS(item));
            }
            if (Array.isArray(_data["weatherConditions"])) {
                this.weatherConditions = [] as any;
                for (let item of _data["weatherConditions"])
                    this.weatherConditions!.push(OWPWeatherCondition.fromJS(item));
            }
            if (Array.isArray(_data["weatherConditionsInNight"])) {
                this.weatherConditionsInNight = [] as any;
                for (let item of _data["weatherConditionsInNight"])
                    this.weatherConditionsInNight!.push(OWPWeatherCondition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WeatherConditionCollectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherConditionCollectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.weatherConditionGroups)) {
            data["weatherConditionGroups"] = [];
            for (let item of this.weatherConditionGroups)
                data["weatherConditionGroups"].push(item.toJSON());
        }
        if (Array.isArray(this.weatherConditions)) {
            data["weatherConditions"] = [];
            for (let item of this.weatherConditions)
                data["weatherConditions"].push(item.toJSON());
        }
        if (Array.isArray(this.weatherConditionsInNight)) {
            data["weatherConditionsInNight"] = [];
            for (let item of this.weatherConditionsInNight)
                data["weatherConditionsInNight"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IWeatherConditionCollectionDto {
    weatherConditionGroups?: OWPWeatherConditionGroup[];
    weatherConditions?: OWPWeatherCondition[];
    weatherConditionsInNight?: OWPWeatherCondition[];
}

export class OWPWeatherConditionGroup implements IOWPWeatherConditionGroup {
    id?: string | undefined;
    name?: string | undefined;
    orderIndex?: number;

    constructor(data?: IOWPWeatherConditionGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.orderIndex = _data["orderIndex"];
        }
    }

    static fromJS(data: any): OWPWeatherConditionGroup {
        data = typeof data === 'object' ? data : {};
        let result = new OWPWeatherConditionGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["orderIndex"] = this.orderIndex;
        return data; 
    }
}

export interface IOWPWeatherConditionGroup {
    id?: string | undefined;
    name?: string | undefined;
    orderIndex?: number;
}

export class OWPWeatherCondition implements IOWPWeatherCondition {
    id?: number;
    main?: string | undefined;
    description?: string | undefined;
    icon?: string | undefined;
    iconUrl?: string;
    weatherConditionGroupId?: string | undefined;

    constructor(data?: IOWPWeatherCondition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.main = _data["main"];
            this.description = _data["description"];
            this.icon = _data["icon"];
            this.iconUrl = _data["iconUrl"];
            this.weatherConditionGroupId = _data["weatherConditionGroupId"];
        }
    }

    static fromJS(data: any): OWPWeatherCondition {
        data = typeof data === 'object' ? data : {};
        let result = new OWPWeatherCondition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["main"] = this.main;
        data["description"] = this.description;
        data["icon"] = this.icon;
        data["iconUrl"] = this.iconUrl;
        data["weatherConditionGroupId"] = this.weatherConditionGroupId;
        return data; 
    }
}

export interface IOWPWeatherCondition {
    id?: number;
    main?: string | undefined;
    description?: string | undefined;
    icon?: string | undefined;
    iconUrl?: string;
    weatherConditionGroupId?: string | undefined;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}